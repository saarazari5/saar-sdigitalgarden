---
{"dateCreated":"2023-06-02 19:44","tags":["computational_complexity","computational_models","computer_science"],"pageDirection":"rtl","dg-publish":true,"permalink":"/cs/computational-complexity/cook-reduction/","dgPassFrontmatter":true}
---


# רדוקציית קוק
תהיינה $A,B$ שתי בעיות חישוב , נגדיר __רדוקציית קוק__ מ $A$ ל $B$ על ידי אלגוריתם פולינומי שפותר את $A$ בעזרת גישה ל ״[אורקל](https://he.wikipedia.org/wiki/%D7%90%D7%95%D7%A8%D7%A7%D7%9C_(%D7%9E%D7%93%D7%A2%D7%99_%D7%94%D7%9E%D7%97%D7%A9%D7%91))״ שפותר את $B$. 
למשל - נזכר בבעיית [[CS/Computational Complexity/Search and Decision Problems#בעיית קליקה\|k-clique]] 

$$R_{kClique}=\{((G,k),S) \ |  \text{S is a clique with size at lest k in G } \}$$

כפי שאמרנו לכל [[CS/Computational Complexity/Search and Decision Problems#מידול בעיות חיפוש\|בעיית חיפוש]] ישנה [[CS/Computational Complexity/Search and Decision Problems#בעיות הכרעה\|בעיית הכרעה]] מתאימה נוכל להגדיר את בעיית ההכרעה כך 

$$S_{clique}= clique = \{(G,k) \ | \ \text{exists a k clique in G}\}$$

נבצע רידוקציית קוק בין $R_{clique}$ ל $clique$ , על ידי בניית אלגוריתם פולינומי שמקבל $(G,k)$ ומחזיר קליקה בגודל $k$ או $\perp$ אם אין כזאת באמצעות גישה לבעיית ההכרעה המתאימה.

$A(G,k)$
1. אם $(G,k)\notin clique$ אז החזר $\perp$ 
2. אחרת, לכל קודקוד $u$ ב $G$ :
	* הסר מ $G$ את $u$ והקשתות הנוגעות בו. נסמן את הגרף החדש $G^{\prime}$ 
	* בדוק האם $(G^{\prime},k)\in clique$ 
		* אם בגרף החדש יש קליקה ממשיכים על $G^{\prime}$ אחרת, ממשיכים על $G$
3. החזר את קבוצת הקודקודים שנותרה ב $G$.

__הסבר:__ האלגוריתם מסיר מהגרף את כל הקודקודים בלעדיהם יש קליקה בגודל $k$ ולבסור מחזיר קליקה בגודל $k$ בזמן $O(|V|)$ .


## מכונת טיורינג בעלת גישת אורקל
נסמן את $M^{A}$ מכונת טיורינג רגילה בתוספת האפשרות לבצע שאילתות לבעיית הכרעה $A$ בעלות של צעד בודד. מכונה שכזו תקרא מכונת טיורינג בעלת גישת אורקל.

## רידוקצייה עצמית
יחס $R\in PC$ ניתן לרידקוצייה עצמית אם אפשר לפתור את $R$ על ידי מספר גישות פולינומי לבעיית ההכרעה $S_{R}$. 

==__טענה:__== אם $R\in PC$ המקיים ש $S_{R}\in NPC$ אזי $R$ ניתן לרדוקצייה עצמית. 
[[CS/Computational Complexity/Search and Decision Problems#הכלה של המחלקות\|בהוכחת המשפט]]  $PC\subseteq PF\leftrightarrow NP\subseteq P$  ראינו רדוקציית קוק מ $R$ ל $S_{R^{\prime}}$ בעיית התחיליות. 
כיוון שנתון ש$S_{R}$ היא [[CS/Computational Complexity/NP-completeness\|NP שלמה]] אזי ישנה [[CS/Computational Complexity/Karp Reduction\|רידוקציית קארפ]] מ $S_{R^{\prime}}$ ל $S_{R}$ ומטרנזיטיביות הרידוקציות נקבל רדוקציית קוק מ $R$ ל $S_{R}$.

==__טענה:__== לכל יחס $R\notin PF$ כך ש $S_{R}\in P$ אין רדוקצייה עצמית. 
נניח בשלילה שיש ל $R$ רדוקצייה עצמית אז ניתן לפתור את $R$ בזמן פולינומי ללא גישת אורקל על ידי החלפת כל גישת אורקל באלגוריתם פולינומי שמכריע את $S_{R}$ ולכן $R\in PF$בסתירה.

__דוגמה:__
בעיה לדוגמה שמשערים שאין לה רדוקצייה עצמית היא 

$$R_{factoring}=\{(n,k) \ | \ n\in\mathbb{N} \ , \  k|n \ \}$$

כאשר $k$ מחלק לא טריוויאלי.

משערים שבעיה זו אינה ב $PF$  אבל יודעים להכריע בזמן פולינומי האם מספר הוא ראשוני או לא כלומר $S_{R}\in P$ ולכן ל $R_{factoring}$ אין רדוקצייה עצמית.

## NP-קשה*
==משפט-== לכל $S\subseteq \{0,1\}^{*}$ קיימת רדוקציית קוק מ $S$ ל $\overline{S}$ . נוכל להוכיח זאת על ידי כך שלכל קלט $x$ נריץ את האורקל המכריע את $\overline{S}$ ונחזיר תשובה הפוכה..

>[!info] הבחנה
>בניגוד לרידוקציית קארפ שבה לא תמיד יש רידוקצייה מבעיה למשלים שלה, ברידוקציית קוק הדבר תמיד מתקיים למשל מ $\overline{SAT}$ ל $SAT$ למרות שהראשונה לא שייכת כנראה ל $NP$. המסקנה המתבקשת היא ש $NP$ ככל הנראה אינה סגורה לרדוקציית קוק
>

__הגדרה__ בעיה $S$ נקראת $NP$ -קשה* אם היא קשה יחסית לרדוקציית קוק. כלומר, קיימת רדוקציית קוק מכל $S^{\prime}\in NP$ ל $S$ .

>[!note] נשים לב
>ב $NPC$ של $A$ דרשנו רדוקציית קארפ מכל $B\in NP$ ל $A$. בעיות $NP$ קשות הן יותר קלות מבעיות $NPC$ , כי בעיות שלמות כ״כ קשות שבקלות אפשר לעבור אליהן ע״י רדוקציית קארפ, לעומת זאת במקרה הזה צריך לעבוד קשה יותר כדי לעשות את המעבר כי הבעיה יותר קלה..

==משפט Lander== 
קיימות בעיות הכרעה שהן ב $NP$ ואינן $NPC$ , כך שאם $P\neq NP$ אז הן אינן ב $P$ . לדוגמה: בעיית $Factoring$ (פירוק לגורמים ראשוניים) היא כזו.