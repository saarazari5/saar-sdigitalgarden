---
{"dateCreated":"2023-04-11 12:23","tags":["computational_complexity","computational_models","computer_science"],"pageDirection":"rtl","dg-publish":true,"permalink":"/computer-science/computation-and-complexity/np-completeness/","dgPassFrontmatter":true}
---


# NP-completeness

__[NP-hardness](https://en.wikipedia.org/wiki/NP-hardness)__ : 
עבור [[Computer Science/Computation and Complexity/Search and Decision Problems#בעיות הכרעה\|בעיית הכרעה]] $S^{\prime}$ , זאת תקרא $NP$-קשה ($NPH$) אם קיימת רדוקציית קארפ מכל בעייה $S\in NP$ ל $S^{\prime}$ . 

__NP-completeness__ :
נאמר ש $S^{\prime}$ היא __NP-שלמה__ אם היא $NP$-קשה וגם $S^{\prime}\in NP$ .

__משפט:__ קיימת בעיה שהיא $NP$-שלמה 
__הוכחה__: נשתמש ב [[Computer Science/Computational Models/Turing Machine\|מכונת טיורינג אוניברסלית]] $u$ . נזכיר שמכונת טיורינג אוניברסלית $u(\langle M,x\rangle)$ מקבלת כקלט תיאור של מכונת טיורינג $M$ וקלט על המכונה ומחזירה $M(x)$ .

נגדיר את בעיית ההכרעה $S_{u}$ הבאה:

$$\displaylines{S_{u}=\{ \\ \langle M,x,1^{t}\rangle \ | \ \exists_{y:|y|\leq t}: M(x,y)=\\1 \wedge M\text{ determine the input after at most t steps} \\ \}}$$

כמו כן נשים לב ש $M$ זאת מכונת טיורינג שמקבלת 2 קלטים ו $1^{t}=\underbrace{1\circ 1\circ 1\circ 1\dots}_{\text{t times}}$ 
זאת אכן בעיית $NP$-שלמה, נוכיח זאת.
* $S_{u}\in NP$ - נוכל להגדיר מוודא פולינומי מהצורה $V_{S_{u}}(\langle M,x,1^{t}\rangle,y)$ כאשר $|y|\leq t\text{ and }|y|\leq |\langle M,x,1^{t}\rangle|$ כלומר $y$ חסום פולינומית באורך הקלט. והמוודא יעבוד באופן הבא: 
	1) הרץ את $u$ על $M(x,y)$ לכל היותר $t$ צעדים.
	2) אם התקבלה תשובה במהלך הריצה החזר $true$ אחרת החזר $false$.

	מהגדרה מתקיים $\exists_{y: |y|\leq P(|\langle M,x,1^{t}\rangle|)}:V_{S_{u}}(\langle M,x,1^{t}\rangle,y)=1\leftrightarrow \langle M,x,1^{t}\rangle\in S_{u}$ כדרוש.

* $S_{u}$ היא שלמה - נראה שלכל $S\in NP$ קיימת [[Computer Science/Computation and Complexity/Karp Reduction#רדוקציית קארפ\|רדוקציית קארפ]] מ $S$ ל $S_{u}$. נוכל לבנות את $f$ פונקציית המרת הקלטים באופן הבא

$$f(x)=\langle V_{S_{}},x,1^{P_{V_{S_{}}}(|x|+ P^{*}(|x|)) }\rangle$$

כאשר $V_{S}$ הוא המוודא הפולינומי של $S$. הקלט ל $V_{S}$ אורכו $|x|+|y|\leq |x|+P^{*}(|x|)$ כלומר פולינומי לאורך הקלט. 
יהי $P_{V_{S}}$ הפולינום החוסם את זמן הריצה של $V_{S}$ כפונקצייה של אורך הקלט שלו. כלומר 

$$T_{V_{S}}(|x|+|y|)\leq P_{V_{S}}(|x|+|y|)\leq P_{V_{S}}(|x|+P^{*}(|x|))$$

כאשר $T_{V_{S}}$ זאת פונקציית זמן הריצה של $V_{S}$ על קלט באורך מסויים. אכן נקבל ש $x\in S$ אמ״מ קיים $y$ חסום פולינומית ב $P^{*}$ כך ש $V_{S}(x,y)=1$ אמ״מ $f(x)\in S_{u}$ שכן השתמשנו באלגוריתם הוידאו כייצוג של המכונה שלנו. _כדרוש_.

## Cook-Levin
משפט cook-levin אומר שבעית [[Computer Science/Computation and Complexity/Search and Decision Problems#3-SAT\|SAT]] היא $NP$-שלמה. 
ההוכחה שלו דורשת להסתכל על בעיה אחרת $CSAT$- נתון מעגל בוליאני ויש להכריע האם יש לו השמה מספקת.
__מעגל בוליאני__ - הוא גרף ללא מעגלים מכוון שקודקודיו מתחלקים ל3 סוגים
1. קודקודי קלט- ללא קשתות נכנסות 
2. קודקודי פלט - ללא קשתות יוצאות, קשת נכנסת אחת
3. שערים- קודקודים עם $deg_{in}\leq 2$ ו $deg_{out}\geq 1$

![Pasted image 20230411185319.png|300](/img/user/Assets/Pasted%20image%2020230411185319.png)

נשים לב ש $CSAT\in NP$ - בהינתן השמה בוליאנית אפשר בזמן פולינומי באורך ייצוג המעגל לבדוק שהיא אכן מתקבלת על ידי המעגל. כלומר שהמעגל מחזיר עליה $true$ . 

### CSAT היא NP-שלמה
השלב הראשון של ההוכחה אם כן היא להראות שלכל $S\in NP$ קיימת $f$ _חשיבה פולינומית_ כך ש $x\in S\leftrightarrow f(x)=C_{x}\in S_{CSAT}$ כאשר 

$$S_{CSAT}=\{C \ |\  C\text{ is a boolean circle graph that can be saturated}\}$$

תהי $S\in NP$ , אזי ל $S$ ישנו מוודא פולינומי $V_{S}$ כך ש $\exists_{y:|y|\leq P^{*}(|x|)}: V_{S}(x,y)=1\leftrightarrow x\in S$ וזמן הריצה של $V_{S}$ חסום על ידי $P_{V_{S}}(|x|+|y|)\leq P_{V_{S}}(|x|+P^{*}(|x|))=t$ .

נבנה טבלה שמייצגת ריצה של מכונת טיורינג על הקלט $(x,y)$ לפי הריצה של $V_{S}$ (אפשר לעשות זאת כי הראנו שכל בעיה ב$NP$ אפשר ״להמיר״ לבעיית NP-שלמה שהקלט שלה הוא מכונת טיורינג)
פונקציית המעברים הינה 

$$\Sigma\times Q\to\Sigma\times Q\times\{+1,-1,0\}$$

כלומר בהינתן תו מהא״ב ומצב נחזיר מצב חדש התו עליו הסרט יצביע ותזוזה של הסרט ימינה או שמאלה או שנשאר במקום לאחר שיורדים לשורה הבאה. נשים לב שמההתנהגות הנ״ל עולה כי לכל תא בשורה כלשהי ערכו ייקבע לכל היותר משלושת התאים שנמצאים מעליו בידיוק. נוכל לנצל את זה כדי לבנות מעגל בוליאני בגודל קבוע של 4 כאשר הפלט הוא הערך שנקבע מפונקציית המעברים כתוצאה משלושת הערכים שמעליו.

![Pasted image 20230412121928.png|400](/img/user/Assets/Pasted%20image%2020230412121928.png)

נתבונן בטבלת ריצת המוודא $V_{S}$ (המכונה הדו מימדית) על קלט $(x,y)$ נרצה להמיר את טבלת הריצה למעגל לוגי $C_{x}$ כך ש $C_{x}(y)=V_{S}(x,y)$ ואז יתקיים  

$$\exists_{y}:C_{x}(y)=1 \leftrightarrow \exists_{y}: V_{S}(x,y)=1\leftrightarrow  x\in S$$

נשים לב שטבלת ריצת המוודא היא בגודל $t\times t$ לכל היותר כאשר בשורה הראשונה רשום הקלט ובשורה האחרונה נמצא הפלט. המכונה תעשה לכל היותר $t$ צעדים כי כל צעד של הראש נרד שורה בטבלה.

בשורה הראשונה בכל תא רשומים שני ערכים, הערך הראשון הוא ביט של אינפורמציה מתוך הקלט והערך השני הוא ״-״ או תיאור מצב המכונה. לכל התאים פרט לתא בו נמצא הראש של המכונה יהיה ״-״ בערך השני של התא ורק בתא בו נמצא הראש יהיה ערך השני התואם למצב המכונה. כמו כן, כל צד של טבלת החישוב (מתוך $t$ צעדים) מחושב על פי טבלת הצעדים של המכונה (פונקציית המצבים המוגדרת למעלה).

ערך כל תא בטבלת החישוב נקבע __רק__ על-פי שלושת התאים שמעליו. לכן ניתן לבנות מעגל קטן בגודל קבוע שלא תלוי בגודל הקלט אך תלוי בטבלת המצבים של המכונה, הקובע ערך התא על פי שלושת ערכי התאים מעליו. 

כעת משהבנו איך תיאור המכונה יעבוד ונראה על הטבלה הנ״ל נוכל לנצל זאת כדי לבנות את המעגל $C_{x}$ . ניקח את הטבלה ונבנה ממנה מעגל בגודל $t\times t$ המורכב מאיחוד של המעגלים הקטנים יותר שקובעים את הערך של כל תא בשורה מסויימת, המשתנים של המעגל יהיו $x,y$ שנמצאים בשורה הראשונה לאחר ההשמה. תוצאת הפלט תהיה `accept` או `true` אמ״מ $V_{S}(x,y)=1$ כלומר המכונה מכריעה את הקלט. במצב שבוא $V_{S}(x,y)=0$ נקבל שגם המעגל שלנו לא ספיק ולכן 

$$\exists_{y}:C_{x}(y)=1 \leftrightarrow \exists_{y}: V_{S}(x,y)=1\leftrightarrow  x\in S$$

__כדרוש__.

### קיימת רידוקציית קארפ מ CSAT ל SAT 
כעת הוכחנו שבעיית $CSAT$ היא $NP$-שלמה, כל שנשאר לעשות הוא לבנות רידוקציית קארפ ממנה ל $SAT$. מטרנזיטיביות הרידוקציית יתקיים שגם היא שלמה. נרצה שבהינתן מעגל בוליאני $C$ בנות נוסחה $\Phi$ בצורת $CNF$ כך ש $C\in CSAT\leftrightarrow \Phi\in SAT$. 

באופן נאיבי היינו יכולים לבנות טבלת אמת למעגל ולבנות ממנה נוסחה בצורת $CNF$ אך הפתרון הזה אינו פולינומי כי עבור $n$ משתנים טבלת האמת תכיל $2^{n}$ תוצאות בטבלת האמת.
נשים לב להבחנה שאם מספר המשתנים היה קבוע היינו יכולים ב $O(1)$ להמיר אותו לנוסחה מהצורה של $CNF$.

אם כן, האינטואיצייה תהיה ״לפצל״ את המעגל לכמה מעגלים קטנים, מכל אחד נבנה נוסחה בצורת $CNF$ ולבסוף נחזיר נוסחה שתהיה מורכבת מכל הנוסחאות הקטנות. 
נסמן את קודקודי הקלט ב $x_{1}\dots,x_{n}$ ואת השערים ב $g_{1},\dots,g_{m}$ ונגדיר נוסחה עם $n+m$ משתנים כנגד קודקוד הפלט והשערים ב $C$. למשל עבור המעגל 
![Pasted image 20230412141128.png|300](/img/user/Assets/Pasted%20image%2020230412141128.png)
נקבל נוסחה מהצורה 
![Pasted image 20230412141152.png|350](/img/user/Assets/Pasted%20image%2020230412141152.png)
נשים לב שהוספנו פרדיקט של `EQ` שהמטרה שלו היא לבדוק שיוויון בין $g_{i}$ המשתנה לנוסחה שממנה הוא מורכב במעגל. באופן הזה הגרף מבטיח שהפרקדיט `EQ` יחזיר $true$ רק אם המשתנה ב״גרף״ החדש שבנינו יקבל ערך ששקול לערך שהוא מקבל במעגל $C$. תחת ההבנה הזאת נוכל לקחת כל פרדיקט `EQ` ולבנות טבלת אמת בין שני הגורמים שמרכיבים אותו. אלו יהיו תמיד על מספר משתנים בגודל קבוע כי מתחילים מהנעלמים ומתקדמים לכיוון הפלט. לאחר שנמיר את ה״גרף״ לפסוקיות בצורה $CNF$ נשים $\wedge$ בין כולם ונגיע לתוצאה הרצויה (_כמעט_).

לכל שער $i$ במעגל $C$ נגדיר נוסחה בצורת $CNF$ נסמנה $\Phi_{i}$ שתהיה מסופקת אמ״מ הערך שמקבל המשתנה $g_{i}$ עקבי עם הערך שמקבל השער $g_{i}$ במעגל $C$. לדוגמה עבור 

$$g_{1}=x_{1}\wedge x_{2}$$

| $x_{1}$ | $x_{2}$ | $g_{1}$ | $g_{1}=x_{1}\wedge x_{2}$ |
| ------- | ------- | ------- | ------------------------- |
| T       | T       | T       | T                         |
| T       | T       | F       | F                         |
| T       | F       | T       | F                         |
| T       | F       | F       | T                         |
| F       | T       | T       | F                         |
| F       | T       | F       | T                         |
| F       | F       | T       | F                         |
| F       | F       | F       | T                         | 

נזכיר שכדי להמיר את הפסוקית לצורת $CNF$ לוקחים את כל הפסוקיות שמחזירות $false$ ומפעילים `not` כל כולם ולכן 

$$\displaylines{
(g_{1}=x_{1}\wedge x_{2})\equiv  \overline{(x_{1}\wedge x_{2}\wedge \overline{g_{1}})}\wedge\overline{(x_{1}\wedge \overline{x_{2}}\wedge {g_{1}})}\wedge\overline{(\overline{x_{1}}\wedge {x_{2}}\wedge {g_{1}})}\wedge \overline{(\overline{x_{1}}\wedge \overline{x_{2}}\wedge {g_{1}})}\\
\equiv (\overline{x_{1}}\vee \overline{x_{2}}\vee g_{1})\wedge (\overline{x_{1}}\vee x_{2}\vee \overline{g_{1}})\wedge (x_{1}\vee \overline {x_{2}}\vee \overline{g_{1}})\wedge (x_{1}\vee x_{2}\vee \overline{g_{1}})
}$$

לאחר שיש לנו את כל הפסוקיות $\Phi_{1}\dots \Phi_{m}$ נרצה לבנות פסוקית נוספת מהקודקוד שנכנס לקודקוד הפלט. כלומר כרגע יש לנו את התוצאה של 

$$\bigwedge_{i=1}^{m}\Phi_{i}$$

נרצה לוודא בנוסף שגם הקודקוד שנכנס לקודקוד הפלט הוא $true$ ולכן נוסיף פסוקית נוספת $\Phi_{m+1}=g_{m}$ במקרה הנ״ל $\Phi_{5}=g_{4}$ . לבסוף נחזיר 

$$\bigwedge_{i=1}^{m+1}\Phi_{i}$$

![Pasted image 20230412150140.png|400](/img/user/Assets/Pasted%20image%2020230412150140.png)
__זמן בנייה__ מספר השערים ב $C$ חסום ליניארית באורך הקלט. עבור כל שער ביצענו $O(1)$ צעדים (כיוון שמשתמשים לכל היותר ב 3 קודקודים) כדי לבנות נוסחה $\Phi_{i}$ .

כעת נרצה להוכיח ש $C\in CSAT\leftrightarrow \Phi\in SAT$ :
$\rightarrow$ נניח $C\in CSAT$ לכן קיימת השמה $z=z_{1}\dots z_{n}$ עבור קודקודי הקלט במעגל שתספק אותו. נסתכל על ההשמה לנוסחה בה כל משתנה $x_{i}$ מקבל את הערך $z_{i}$ וכל משתנה $g_{i}$ מקבל את הערך של השער $g_{i}$ במעגל ל $C$ .
לפי הבנייה כל $\Phi_{i}$ מסופקת וכן הפסוקית $\Phi_{m+1}$ מסופקת כי $C(z)=T$ . 

$\leftarrow$ נניח $\Phi\in SAT$ לכן קיימת השמה $z=z_{1},\dots,z_{n}$ למשתנים ב $\Phi$ שמספקת אותה. נשים לב שההצבה הנ״ל מספקת את המעגל  מהבנייה של $\Phi$. 

>[!note] הבחנה
>3SAT היא גם כן $NP$-שלמה כי ראינו עכשיו שברידוקצייה מ $CSAT$ ל $SAT$ בכל פסוקית יש לכל היותר 3 ליטרלים

>[!note] הבחנה
>ראינו ש $SAT$ היא $NPC$ וראינו רדוקציית קארפ מ $SAT$ ל $IS$ ולכן היא גם כן שייכת ל $NPC$

>[!note] תזכורת
>אם יש [[Computer Science/Computation and Complexity/Karp Reduction\|רידוקציית קארפ]] מ $A$ ל $B$ כך ש $B\in NP$ אזי $A\in NP$

## Vertex Cover 
נתון גרף $G=(V,E)$ ונתון מספר $k$. נרצה לדעת האם גרף $G$ ישנם $k$ קודקודים שמכסים את כל הקשתות. 

![Pasted image 20230602191430.png](/img/user/Assets/Pasted%20image%2020230602191430.png)

נרצה להראות שזאת אכן בעיה $NP$ שלמה. 
ראשית קל להראות שהיא ב $NP$ כי תמיד אפשר לבדוק בזמן פולינומי שאוסף קודקודים שניתן כעדות, אכן מכסה את הקשתות. 

כעת, נראה רדוקציית קארפ מ $IS$ ל  $VC$. 
לשם הרידקוצייה נוכיח את טענת העזר הבאה:
עבור $G=(V,E)$ ו $S\subseteq V$ קבוצה בת״ל המקיימת $|S|=k$ . אזי, $V-S=\overline{S}$ היא קבוצה המקיימת $VC$. יותר מזה, 

$$S \text{ is independent} \leftrightarrow \overline{S} \text{ is vertex cover}$$

__הסבר:__
אם $S$ בלתי תלוי אזי לכל קשת $(u,v)\in E$ מתקיים ש $u\notin S$ או ש $v\notin S$ כי אחרת שניהם ב $S$ וזו סתירה לכך ש $S$ בת״ל. כלומר בהכרח מתקיים שאחד מהם נמצא ב $\overline{S}$ ולכן זאת תכסה את כל הקשתות. 
מצד שני, אם $\overline{S}$ היא ב $VC$ אזי $S$ היא בת״ל תחת אותו הסבר, לא ייתכן שישנה קשת $(u,v)$ ששני קצותיה נמצאים בתוך $S$ .

מטענת העזר נוכל לבנות רידוקציית קארפ מ $IS$ ל $VC$ על ידי 

``` psuedo
f(G,k)= (G, |V(G)|-k)
```
הנכונות נובעת ישירות מטענת העזרת.


