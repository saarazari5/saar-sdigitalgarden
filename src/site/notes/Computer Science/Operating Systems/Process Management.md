---
{"dateCreated":"2023-09-03 13:38","tags":["operating_system","computer_science"],"pageDirection":"rtl","dg-publish":true,"permalink":"/computer-science/operating-systems/process-management/","dgPassFrontmatter":true}
---


# Processes
תהליך הוא תוכנית שרצה ברגע מסויים. כלומר ברגע שתוכנית כלשהי רצה על המחשב מאותחל process שמריץ את אוסף הפקודות שמרכיבות את התוכנית. 

מספר תהליכים יכולים להריץ את אותה התוכנית. בעצם process מהווה קונטקסט דינמי של התוכנית שלנו.
process מריץ את הקוד באופן סדרתי, פקודה אחר פקודה. 

__Process State__ מכיל לפחות:
1) הקוד של התוכנית שרצה
2) המידע הסטטי של התוכנית הרצה
3) heap ו HP (heap pointer)
4) Program Counter עבור הפקודה הבאה
5) execution stack
6) ערכי CPU Registers
7) OS Resources
8) execution state (ready, running)

נבדיל בין קוד לתהליך: 
הקוד שלנו הוא סטטי והוא בעצם פשוט אוסף פקודות למשל 

```c
void x(int b) {
//PC-> 
	if(b==1) {...}
}

main() {
	int a = 2;
	x(a);
}
```

כאשר  ה PC נמצא באזור המסומן תמונת המצב של הזכרון או הprocess state יהיו: 
![Screenshot 2023-09-03 at 13.51.22.png|450](/img/user/Assets/Screenshot%202023-09-03%20at%2013.51.22.png)
ב[[Virtual Memory\|מרחב הזכרון הוירטואלי]] אנחנו משתמשים בכתובות לוגיות, כלומר, הכתובת הראשונה היא 0 עד לכתובת המקסימלית של התהליך. הזכרון הזה מחולק למקטעים ולכל מקטע יש תפקיד :
![Screenshot 2023-09-03 at 13.52.40.png|300](/img/user/Assets/Screenshot%202023-09-03%20at%2013.52.40.png)

## Process execution state
![Screenshot 2023-09-03 at 14.06.46.png](/img/user/Assets/Screenshot%202023-09-03%20at%2014.06.46.png)
_new:_ מערכת ההפעלה בונה את ה process state
_running:_ התהליך מריץ פקודות על ה CPU 
_ready:_ התהליך מוכן לרוץ אבל מחכה ל CPU
_waiting:_ ממתין להשלמת event כלשהו
_terminated:_  מערכת ההפעלה הורסת את התהליך.

התרשים למעלה מתאר את המכונת מצבים שמתארת את מחזור החיים של תהליך. שינויים במצבי התהליך יכולים להשתנות בגלל 
* [System Call](https://www.knowledgehut.com/blog/web-development/system-calls-in-os)
* [[Scheduling\|Scheduling]]
* [[Computer Science/Operating Systems/Interrupts\|Interrupts]]

## Process Control Block
מערכות הפעלה מרובות מעבדים נשענות על תזמון בין תהליכים. מדובר בתהליך של הוצאת process מהמעבד והחלפתו באחד אחר. 
אנחנו יודעים שמספר התהליכים שיכולים לרוץ בכל רגע נתון חסום על ידי מספר המעבדים. לשם ניהול זה מערכת ההפעלה הגדירה מבנה נתונים שנקרא PCB.

ה PCB הוא מבנה נתונים של מערכת ההפעלה שמאפשר מעקב אחר כל תהליך. לכל תהליך יש PCB והוא מאפשר מעקב אחר execution state ומיקום בזכרון של כל תהליך. עבור תהליך חדש שנוצר מערכת ההפעלה מבצעת אלוקצייה של PCB. ובעת שתהליך מת מערכת ההפעלה מבצעת דה-אלוקצייה של PCB.

![Pasted image 20230903141121.png](/img/user/Assets/Pasted%20image%2020230903141121.png)

באמצעות ה PCB מערכת ההפעלה יכולה בקלות לשמור state של process בעת שמשתנה מצבו למשל בעת קריאה ל IO, ולטעון אחד אחר לזכרון
![Screenshot 2023-09-03 at 14.13.07.png|400](/img/user/Assets/Screenshot%202023-09-03%20at%2014.13.07.png)

## Process Scheduling Queues
מערכת ההפעלה מנהלת את כל הPCB של התהליכים במספר תורים:
* Job Queue- כל התהליכים במערכת
* Ready Queue- מכיל את כל התהליכים במצב ready
* Waiting Queue- מכיל את כל התהליכים במצב wait
* Device Queue- לכל רכיב I/O יש תור כזה והוא מכיל את כל תהליכים שמחכים לרכיב המסויים שיתפנה

![Screenshot 2023-09-03 at 14.17.36.png|400](/img/user/Assets/Screenshot%202023-09-03%20at%2014.17.36.png)

תהליך חדש לאחר סיום יצירתו עובר מיד ל ready queue , לאחר מכן יש ברגע שהוא מקבל זמן מעבד הוא יכול לרוץ עד סיום או שיהיה איזה מאורע שיעביר אותו למצב waiting

## Types of Schedulers
__Long Terms:__  קובע אילו תוכניות יתקבלו לעיבוד למערכת. הוא בוחר תהליכים מהתור ואז טוען אותם לזיכרון כדי שיוכלו להתבצע. במילים אחרות הוא קובע איזה תהליכים ייווצרו ויכנסו למצב Ready. בנוסף הוא גם יכול לבצע פעולות swap שמוציאות תהליך מהזמן מעבד ומאחסנות אותו בהתקן זכרון חיצוני ולא בזכרון הראשי.  כמו כן הוא קובע גם את degree of multiprogramming.

__Short Terms:__  קובע איזה מהתליכים שנמצאים ב ready queue יקבלו זמן מעבד. שיטה זו יותר מהירה שכן אפשר לתזמן באמצעות טכניקות פשוטות יותר מפעולות ה swap, למשל שיטת FCFS-first come first serve.
![Pasted image 20230903144147.png](/img/user/Assets/Pasted%20image%2020230903144147.png)

## Context Switch
מתאר את הפעולה של שמירת מצב process שרץ על מעבד כדי שנוכל להמשיך את ריצתו בזמן מאוחר יותר ובנוסף לשחזר תהליך עם state אחר שנשמר קודם לכן לשם ריצתו. פעולה זו מאפשרת למספר תהליכים לחלוק בינהם זמן מעבד וזה חלק אינטרגרלי מ multiprogramming OS. זמן הביצוע של context switch הוא overhead שכן יש שימוש במשאבי מערכת ללא שירות המשתמש של מערכת ההפעלה. כמו כן, זה תהליך שנחשב יקר ולכן נוצרו כל מיני שיטות לצמצום זמן זה כמו שימוש ב [[Computer Science/Operating Systems/Threads\|Threads]] וחומרות ייעודיות. 

## Process Creation
תהליך אחד יכול לייצר תהליך אחר כדי לבצע עבודה מסויימת. 
היוצר נקרא ״אב״ והנוצר נקרא ״בן״. תהליך אב יכול לחכות לתהליך הבן שיסתיים או להמשיך במקביל.

>[!info]
>במערכות מבוססות UNIX תהליך האב הראשון הוא תהליך הinit ולו יש pid-process identifier של $1$.

יש כל מיני גישות לשיטוף מידע בין תהליכי אב ובן:

1. כלל המשאבים שמוקצים לאב, מוקצים גם לבנים שלו.
2. האב מגדיר לתהליך הבן חלק מהשאבים שלו עצמו, הבן לא יכול להשתלט על כל המשאבים של האב. 
3. הפרדה מלאה בין האב והבן. 

הגישות הללו נקבעות בהתאם למערכת ההפעלה עצמה. 

## Process Termination
בסיום תהליך והרצת הפעולה exit מערכת ההפעלה מוחקת את התהליך מרשימת התהליכים ומפנה את המשאבים לצורך הקצאה מחדש. 
תהליך אב גם יכול לגרום להפסקת הריצה של תהליך הבן. 

>[!info] הבחנה
בUNIX כאשר תהליך אב מת הבנים שלו מועברים להיות ילדים של תהליך ה init. 

## Interprocess Communication
