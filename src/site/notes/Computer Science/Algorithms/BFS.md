---
{"dateCreated":"2023-01-15 23:34","tags":["algorithms","computer_science"],"pageDirection":"rtl","dg-publish":true,"permalink":"/computer-science/algorithms/bfs/","dgPassFrontmatter":true}
---


# BFS
אחד האלגוריתמים הפשוטים לחיפוש גרפים, ולביצוע [[Computer Science/Algorithms/Single-Source Shortest Paths (SSSP)\|SSSP]] .
בהינתן גרף $G=(V,E)$ וקודקוד מקור $s\in V$ , $BFS$ עובר בצורה סיסטמטית על קשתות הגרף ומבקר בכל קודקוד $v$ הנגיש מ $s$ (נגיש = קיים מסלול).
תוך כדי האלגוריתם מחשב את המרחק (מספר הקשתות במסלול) מ$s$ לכל קודקוד נגיש, נוכיח בהמשך שזה המסלול הקצר ביותר. בנוסף הוא מייצר עץ רוחב Breadth-First Tree או עץ מסלולים ששורשו $s$ שמכיל את כל הקודקודים והמסלולים הפשוטים הנגישים מ $s$.

כמה דגשים חשובים:
א) האלגוריתם עובד עם גרף מכוון ולא מכוון. __ללא פונקציית משקל.__
ב) האלגוריתם מבקש בקודקודים במרחק $k$ מ $s$ לפני אלה שנמצאים במרחק $k+1$ 

בדומה ל [[Computer Science/Algorithms/DFS\|DFS]] במהלך ריצת האלגוריתם, קודקוד יכול להיות צבוע באחד משלושת הצבעים:
לבן- כל הקודקודים מתחילים לבנים, וקודקוד בצבע לבן אומר שעדיין לא ביקרנו בו.
אפור- קודקוד בצבע אפור אומר שביקרנו בו ועדיין לא סיימנו את הטיפול בכל שכניו.
שחור- אומר שסיימנו לטפל בקודקוד.

עבור קשת $(u,v)\in E$ אם $u$ שחור אז בהכרח $v$ או אפור או שחור לפי מה שאמרנו.
כמו כן, נשייך לכל קודקוד ערך $\pi$ המהווה קודקוד האבא בעץ הרוחב. כל הקודקודים מתחילים עם $\pi = NULL$ וכשנציב ערך , הוא לא ישתנה לאורך כל האלגוריתם. 
בנוסף בדומה לאלגוריתמים נוספים שמחשבים את ה SSSP , לכל קודקוד משוייך ערך d שבסיום הריצה יכיל את המרחק המינימלי של הקודקוד הזה מ $s$, ואם אין כזה הערך יישאר $\infty$ .

``` psuedo
BFS(G,s)
	for each u in V-{s}:
		u.color = WHITE
		u.d = ∞
		u.𝝅 = NIL
	s.color = GRAY
	s.d = 0
	s.𝝅 = NIL
	Q= {}
	Q.enqueue(s)
	while Q != {}:
		u = Q.dequeue()
		for each v in adj(u):
			if v.color == WHITE
				v.color = GRAY
				v.d = u.d + 1
				v.𝝅 = u
				Q.enqueue(v)
		u.color = BLACK
```

![Pasted image 20230115235547.png|400](/img/user/Assets/Pasted%20image%2020230115235547.png)

* האלגוריתם מניח ש $G$ מיוצג על ידי רשימת שכנויות
* $Q$ הוא תור FIFO.

## זמן ריצה 
בגלל שלאחר האתחול האלגוריתם לא צובע אף קודקוד בצבע לבן אנחנו מבטיחים שהתנאי `if color == white` יתקיים עבור כל קודקוד פעם אחת בידיוק. 
פעולת הכנסה והוצאה הן בעלות קבועה $O(1)$ וזאת קוראת לכל קודקוד את כל שכניו כלומר $O(E)$ עבור כל הקודקודים. לכן הפעולה הזאת $+$ פעולת האתחול שלוקחת $O(V)$ אומר שהאלגוריתם BFS יעלה לנו:

$$O(V+E)$$


## מסלולים קצרים ביותר
נרצה להוכיח שבסיום ריצת $BFS$ עבור קודקוד מקור $s$ מתקיים 

$$\forall_{v\in V}: \delta(s,v) = v.d$$

ואם אין מסלול אז הערך הוא $\infty$ .

נוכיח כעת כמה למות שיעזרו לנו בשביל ההוכחה שBFS מביא את המסלולים הקצרים ביותר עבור גרף לא ממושקל:

### אי שיוויון המשולש
יהי $G=(V,E)$ גרף מכוון או לא מכוון ויהי קודקוד מקור $s$. אזי

$$\forall_{(u,v)\in E}: \delta(s,v)\leq \delta(s,u)+1$$
_הוכחה_:
* אם u לא נגיש מ s אז $\delta(s,u)=\infty$ והטענה מתקיימת.
* אם u נגיש מ s אז גם v. נניח בשלילה $\delta(s,v)>\delta(s,u)+1$ 
נגדיר את P המסלול הקצר ביותר מ $s$ ל $u$ ולכן אורכו $\delta(s,u)$  אזי אם נוסיף את $v$ למסלול הזה נקבל שאורכו $\delta(s,u)+1$ , וזה אורך מסלול מ $s$ ל $v$ שקצר יותר מ $\delta(s,v)$  __בסתירה למינימליות של מסלול קצר ביותר__.

### חסם עליון
יהי $G=(V,E)$ גרף מכוון או לא מכוון ויהי קודקוד מקור $s$. אזי בסיום ריצת BFS 


$$\forall_{v\in V} : v.d\geq \delta(s,v)$$
_הוכחה:_
באינדוקצייה על מספר פעולות ההכנסה לתור.
__בסיס-__ הפעולה הראשונה היא הכנסת $s$. בזמן זה מתקיים $0=\delta(s,s)=s.d$ וכל שאר הקודקודים מקיימים $v.d=\infty$ ולכן הנ״ל מתקיים בשלב זה.

__צעד__ - נניח שהטענה נכונה לאחר הכנסת $k$ קודקודים לתור. נוכיח שהטענה נכונה עבור הקודקוד ה $k+1$ . נסמן את הקודקוד הזה ב $v$ , שהוכנס תוך כדי סריקת רשימת השכנויות של $u$ .
לפי הנחת האינדוקצייה 

$$u.d \geq \delta(s,u)$$

לפי אי שיוויון המשולש ולפי הנחת האינדוקצייה

$$\displaylines{
v.d = u.d+1 \geq \delta(s,u)+1 \geq \delta(s,v)
}$$

ואז $v$ נכנס לתור וצבעו אפור, צבעו לא יהפוך ללבן לאורך ריצת האלגוריתם ולכן לא יוכנס שוב לתור כלומר $v.d$ לא ישתנה __כדרוש__.

### לכל היותר שני ערכי d שונים בתור בכל רגע
נניח שבמהלך ריצת BFS על הגרף , התור $Q$ מכיל את הקודקודים $[v_{1},v_{2}\dots,v_{r}]$  כאשר $v_{1}$ הוא ראש התור. אזי:

א) $v_{r}.d\leq v_{1}.d+1$ 
ב) $\forall_{1\leq i\leq r}: v_{i}.d\leq v_{i+1}.d$ 

נוכיח באינדוקצייה על מספר פעולות התור. 
_בסיס_:
פעולת ההכנסה הראשונה = הכנסת $s$ לתור, הטענה כמובן מתקיימת.
פעולת ההוצאה הראשונה = הוצאת $s$ מהתור, לא נשארו קודקודים, הטענה מתקיימת.

_צעד:_
נוכיח נכונות אחרי הוצאת או הכנסת קודקוד כאשר מניחים נכונות לכל אלה שנמצאים לפני הפעולה.

__הוצאה =__ נוציא את ראש התור $v_{1}$ עליו מתקיימת הטענה, לכן אם התור ריק סיימנו. אם לא אז $v_{2}$ כעת נמצא בראש. לפי הנחת האינדוקצייה 

$$v_{1}.d\leq v_{2}.d\rightarrow v_{1}.d +1\leq v_{2}.d+1$$

וגם מתקיים 

$$v_{r}.d\leq  v_{1}.d +1\leq v_{2}.d+1$$

זה הוכחה של סעיף א.
נכונות של סעיף ב נובעת מכך שלפי הנחת האינדוקצייה $v_{2}.d\leq v_{3}.d$ גם כ $v_{1}$ היה בתור והוצאתו לא שינתה ערכים ולכן היחס סדר הזה עדיין נשמר. 

__הכנסה =__ נסמן $v_{r+1}$ כקודקוד שנכנס לסוף התור. כדי להגיע להכנסה הזאת הוצאנו קודקוד $u$ שהוא אבא של $v_{r+1}$ . מהנחת האינדוקצייה יתקיים עבור הראש החדש של התור ש 

$$u.d\leq v_{1}.d$$

וזה בלי קשר למתי $v_{1}$ נכנס לתור, כלומר לא משנה האם הוא היה בתור בזמן הוצאת $u$ או שהוא נכנס לתור כתוצאה מסריקת השכנים.

מהאלגוריתם מתקיים 

$$v_{r+1}.d= u.d+1\leq v_{1}.d+1$$

וזה ההוכחה של סעיף א.
על פי הנחת האינדוקצייה לפני הוצאתו מהתור מתקיים (כמובן שמתקיים גם לאחר ההוצאה)

$$v_{r}.d\leq u.d+1$$

ולכן 

$$v_{r}.d\leq v_{r+1}.d$$

כיוון שמהנחת האינדוקצייה אנחנו יודעים שלכל $j<r$ מתקיים $v_{j}.d\leq v_{r+1}.d$ אז סיימנו כעת גם להוכיח את סעיף ב.

__מסקנה__ נניח ש $v_{i}$ נכנס לפני $v_{j}$ לתור במהלך BFS אזי 

$$v_{i}.d\leq v_{j}.d$$
זה מסתדר עם העובדה שאנחנו סורקים לרוחב את הגרף כלומר מתחילים מהשכנים המיידים של $s$ ומעלים את d עבורם ב 1 וכן הלאה ממשיכים לשכנים שלהם עד שמגיעים לקודקודים ה״רחוקים״ ביותר מ $s$ .

## נכונות BFS
נרצה להוכיח כמובן שבסיום ריצת BFS על גרף $G=(V,E)$ עם קודקוד מקור $s$ יתקיים

$$\forall_{v\in V}: v.d=\delta(s,v)$$
כמו כן נוכיח שאחד המסלולים הקצרים ביותר מ $s$ ל $v$ הוא המסלול הקצר ביותר מ $s$ ל $v.\pi$ עם הוספת הקשת $(v.\pi ,v)$ .

נב״שׁ שקיים קודקוד $v\in V$ כך ש $v.d\neq \delta(s,v)$ בסוף האלגוריתם.
בדומה להוכחה ב [[Computer Science/Algorithms/Single-Source Shortest Paths (SSSP)\|SSSP]]  אנחנו יודעים להגיד ש $s\neq v$ וש  $v.d>\delta(s,v)$  , כלומר , קיים מסלול בין $s$  ל $v$ (אחרת הערך היה $\infty$ ומהלמות שהוכחנו למעלה ערך זה לא משתנה בסתירה להנחה שלנו).
נסמן את $u$ הקודקוד הקודם של $v$ במסלול הקצר ביותר שאורכו $\delta(s,v)$ ולכן 

$$v.d>\delta(s,v)=\delta(s,u)+1 = u.d +1$$
כעת נבין מה קורה כשמוציאים את $u$ מהתור. בזמן הזה $v$ יכול להיות צבוע באחד משלושת הצבעים 

א) אם הוא לבן: אז נקבל שבבדיקת שכני $u$ נעשה השמה $v.d= u.d+1$ _בסתירה_.
ב) אם הוא שחור: זאת אומרת שהוצאנו מהתור לפני שהוצאנו את $u$ ולכן מהמסקנה שהוכחנו, $v.d\leq u.d$ בסתירה.
ג) אם הוא אפור: אז קיים קודקוד $w$ כך ש $v.\pi = w$ ואז $v.d = w.d +1$ ולפי אותה מסקנה שהראנו $w.d\leq u.d$ כלומר $v.d\leq u.d+1$ בסתירה.

סך הכל הוכחנו שלכל קודקוד יתקיים $v.d=\delta(s,v)$ בסוף האלגוריתם כדרוש.
כמו כן כאשר האבא של $v$ הוא $u$ אז נקבל בשורת ההשמה של האלגוריתם 

$$v.d= u.d+1$$

כלומר שהמסלול הקצר ביותר מ $s$ ל $v$ הוא המסלול הקצר ביותר מ $s$ ל $u$ פלוס 1.

## עץ הרוחב
BFS בונה עץ רוחב במהלך ריצתו ביחס לערכי $\pi$ .
נגדיר Predecessor subgraph של $G$ להיות תת הגרף $G_{\pi}(V_{\pi},E_{\pi})$ כאשר:

$$\displaylines{
V_{\pi}= \{v\in V \ \ | \ \ v.\pi \neq Null\}\cup \{s\} \\
E.\pi = \{(v.\pi , v)\in E \ \ | \ \  v\in V_{\pi}- \{s\} \}
}$$

תת הגרף הוא עץ הרוחב של $G$ עם שורש $s$ וכל הקודקודים הנגישים ממנו. כמו כן לכל הקודקודים ב $V_{\pi}$ מתקיים שתת הגרף הזה מכיל מסלול ייחודי מ $s$ ל $v$ שאורכו $\delta(s,v)$ כלומר מסלול קצר ביותר בגרף המקורי.

ההוכחה שאכן עץ הרוחב הוא תת הגרף הזה נובעת ישירות מהאלגוריתם אנחנו יודעים שהאלגוריתם מגדיר 

$$v.\pi =u\leftrightarrow (u,v)\in E \wedge \delta(s,v)<\infty$$
כלומר ההשמה הזאת מתרחשת רק אם היחס בינהם הוא שהם מרכיבים קשת וגם $v$ נגיש מ $s$ . מהשמה זאת ומהוכחת הנכונות של BFS אנחנו יודעים שבסופו של האלגוריתם כל הקודקודים שיסומנו בשחור ירכיבו את המסלולים הקצרים ביותר מ $s$ לכל הקודקודים האחרים ומהגדרת $G_{\pi}$ הוא עץ ולכן מכיל מסלול פשוט ייחודי מ $s$ לכל הקודקודים הנגישים.

## הדפסת מסלול קצר ביותר

הפרוצדורה הבאה מדפיסה את הקודקודים הנמצאים על המסלול מ $s$  ל $v$ :

``` psuedo
print_path(G,s,v) 
	if v==s
		print s
	else if v.𝜋 == Nil 
		no path from s to v exists
	else print_path(G,s,v.𝜋)
		print v
```