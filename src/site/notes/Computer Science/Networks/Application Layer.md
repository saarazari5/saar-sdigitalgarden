---
{"dateCreated":"2024-02-09 13:13","tags":["networks"],"pageDirection":"rtl","dg-publish":true,"permalink":"/computer-science/networks/application-layer/","dgPassFrontmatter":true}
---

# שכבת האפליקציה
שכבת היישום (באנגלית: Application) נקראת גם: שכבת התוכנה או שכבת האפליקציה. היא השכבה השביעית והעליונה של [[Computer Science/Networks/Computer Networks Intro and Protocol layers\|מודל ה-OSI]] והחמישית במודל TCP/IP. היא ממונה על אספקת שירותי הרשת לתוכנות בהן משתמש משתמש הקצה. שכבת היישום משתמשת בשירותיה של שכבת הייצוג של מודל ה-OSI ואינה מספקת שירותים לאף שכבה אחרת במודל ה-OSI.

שכבת היישום היא זו הקובעת את סוג התקשורת בין מחשבים. למשל, היא קובעת האם מדובר בתקשורת "שרת–לקוח" (client-server) שבה מחשב אחד (השרת) מספק נתונים לאחר (הלקוח) - כמו בגלישה באינטרנט, או שמדובר בתקשורת "קצה לקצה" (peer to peer), שבה כל אחד מהמחשבים הוא גם שרת וגם לקוח - כמו ברשתות שיתוף קבצים. 

### DHCP 
Dynamic Host Configuration Protocol (DHCP) הוא פרוטוקול client/server שמספק באופן אוטומטי ודינמי, את הכתובת [[Computer Science/Networks/IP\|IP]] של host כאשר הוא מתחבר לרשת בפעם הראשונה.

באופן כללי הפרוטוקול עובד באופן הבא:
א) שליחת broadcast מסוג DHCP discover
ב) שרת ה DHCP מגיב עם DHCP offer
ג) הhost מבקש כתוב IP עם DHCP request 
ד) השרת שולח את הכתובת ו DHCP ack


![Screenshot 2024-02-09 at 13.25.13.png|450](/img/user/Assets/Screenshot%202024-02-09%20at%2013.25.13.png)

שרת ה DHCP מביא מידע קונפיגורטיבי נוסף חוץ מה IP שמוקצה לרשת החדשה. 
	א. הכתובת של הראוטר הראשון שקופצים אליו מחוץ לרשת המקומית במידה וצריך.
	ב. שם וכתובת של שרת הDNS
	ג. network mask שגם עליה נדבר בהמשך. 

![Screenshot 2024-02-09 at 13.33.07.png](/img/user/Assets/Screenshot%202024-02-09%20at%2013.33.07.png)

DHCP עובד בפרוטוקול [[Computer Science/Networks/Transport Layer#UDP\|UDP]] ולכן הוא connectionless לכן צריך להצמיד מזהה להודעה כדי שמי שמקבל את ההודעה ידע שהיא רלוונטית אליו בשכבת האפליקצייה. 

![Pasted image 20240209133707.png](/img/user/Assets/Pasted%20image%2020240209133707.png)
ניתן לראות שבשליחת ברשה ראשונית ה source IP הוא עדיין $0.0.0.0$ כי הוא לא מוקצה.

![Pasted image 20240209133755.png](/img/user/Assets/Pasted%20image%2020240209133755.png)
השרת שולח תגובת Offer ב Broadcast עם המזהה הספציפי שדיברנו עליו מקודם והכתובת IP המוקצת.

ברגע שהhost מחליט להסכים לקבל את ה IP הוא מבקש גם מידע נוסף 
![Screenshot 2024-02-09 at 13.39.22.png](/img/user/Assets/Screenshot%202024-02-09%20at%2013.39.22.png)

>[!info] הבחנה
>ההודעת Offer בדוגמה למעלה הייתה ב broadcast אבל היא גם יכולה להשלח בבקשת [Unicast](https://castr.com/blog/unicast-vs-multicast-vs-broadcast/) . במצב זה השרת שולח בקשה ל IP __שהוא עוד לא הקצה למחשב החדש שהתחבר__ 
>![Screenshot 2024-02-09 at 13.41.41.png|450](/img/user/Assets/Screenshot%202024-02-09%20at%2013.41.41.png)

>[!info] הבחנה
>אם קיימים שרתי DHCP ברשת המקומית בעלי כתובת פנויה לחלוקה, הלקוח יקבל חבילת offer עם כתובת IP מכל אחד מהם (בהנחה שאין חסימה של מעבר חבילות DHCP בין השרת ללקוח, למשל על ידי חומת אש).

## DNS
מחשבים מתקשרים זה עם זה באמצעות [[Computer Science/Networks/IP\|IP]] אך רוב הגולשים לא מודעים לקיומן בכלל. 
כדי להפוך את הגלישה לנוחה, לכל אתר מוצמד שם דומיין שהוא שם מילולי ומייצג את הכתובת. לשם כך הוגדר הפרוטוקול DNS שרץ על UDP. הפרוטוקול מהווה מעין ״ספר טלפונים״. הדפדפן מאחורי הקלעים על כל דומיין פונה לשרת ה DNS כדי לקבל את הכתובת ה IP.

![Screenshot 2024-02-10 at 0.40.30.png](/img/user/Assets/Screenshot%202024-02-10%20at%200.40.30.png)

מבנה של שמות דומיין מזכיר עץ , הסיומות בשם הדומיין מייצגות את סדר הפניה לשרתי DNS מהסוף להתחלה. נדגים על `cyber.org.il` :
	_א)_ בגזע של שמות הdomain נמצא שרת DNS בשם Root- הוא שומר את כתובת ה IP המשמשים רק ב top level domains למשל סיומות של מדינות $il,uk$ וסיומות כמו $com$.
	_ב)_ בשלב הבא מתבצעת הפנייה אל שרת ה DNS האחראי על סיומות $il$ ממנו מתפצלים ענפים נוספים כמו $org.il$ 
	ג) בשלב האחרון מתבצעת פנייה לשרת DNS שהשורש שלו הוא $org.il$ ומבקש את הכתובת של cyber.org.il .

 ![Pasted image 20240210004655.png](/img/user/Assets/Pasted%20image%2020240210004655.png)

![Screenshot 2024-02-10 at 0.54.00.png](/img/user/Assets/Screenshot%202024-02-10%20at%200.54.00.png)

__שרתי ה Root:__
יש כ 13 שרתי root לוגיים (של חברות רשת מסויימות שהשרתי root הפיזיים שלהם מפוזרים בכל מיני מקומות). 

>[!info] שינוי בהגדרות שרת DNS
> בהגדרות הרשת של המחשב מוגדר לנו לאיזה שרת DNS לפנות כאשר אנחנו רוצים לקבל כתובת של דומיין מסוים. אלו הגדרות שמוזנות באופן אוטומטי דרך הראוטר אבל נתנות לשינוי או להגדיר באופן ידני את כתובת ה IP של השרת DNS שנרצה לפנות אליו
> 

### DNS Resolver
הresolver היא התוכנה שפותרת שאילתות DNS. 
מההסבר שהבאנו למעלה, אפשר להניח שמשיכת כתובת IP היא תהליך ארוך שיכול לעבור בכמה וכמה שרתים. כדי לייעל את התהליך הזה ישנם שני פתרונות 

א. שימוש ב Cache כדי להכיל מיפוי לכתובות שכבר חיפשנו כדי לא לחפש אותם שוב.
ב. פרוטוקול DHCP יביא כתובת לשרת DNS של הרשת המקומית (לרוב זה יהיה הראוטר) והמטמון ישב שם. היתרון בזה הוא שהמטמון משותף בין כל הhosts ברשת המקומית ויש שיתופיות של כתובות , resolver אחד ישתף המון לקוחות. 

ה Resolver עובד בצורה חצי איטרטיבית וחצי רקורסיבית, הבקשה עולה לשרת ה DNS המתאים ומשם הולכים לפי העץ, תחילה פונים ל root שמחזיר את הכתובת הבאה של השרת שעלינו לשאול אותו (במקום שהוא יעשה זאת וככה יורד ממנו עומס) השרת DNS המקומי שלנו מכאן ממשיך לשאול בתורות את השרתים שחוזרים עד שמתקבלת תשובה כפי שמתואר בתרשים הבא

![Pasted image 20240210013914.png|350](/img/user/Assets/Pasted%20image%2020240210013914.png)

הריקורסיה באה לידי ביטוי בכך שיכול להיות שגם השרתים עצמם יצטרכו לעבור תהליך דומה. 

בעצם הבעיה שחסכנו בשיטה זאת היא heavy load על השרתי root כפי שהיה קורה אם היינו עובדים בשיטה ריקורסיבית מלאה :

![Screenshot 2024-02-10 at 1.40.15.png|350](/img/user/Assets/Screenshot%202024-02-10%20at%201.40.15.png)


### שדות DNS
![Pasted image 20240210011949.png](/img/user/Assets/Pasted%20image%2020240210011949.png)
כפי שאמרנו ניתן לראות שהחבילה נשלחת בשכבת האפליקציה מעל UDP. 
א) בצהוב ניתן לראות את ה Transaction ID שאמרנו שהוא נפוץ מעל UDP
ב) השדה בכחול הוא flags ששדה זה מורכב משמונה דגלים בעלי משמעויות שונות, הדגל הנ״ל מציים שמדובר בשאילתה סטנדרטיץ
ג) RR- Resource Records בירוק זה מידע שמתאר כמה רשומות מכילה חבילת ה DNS. 
ד) השאלתה עצמה בסוף של הבקשה מכילות Name,Type ו Class כאשר האחרון מתאר את סוג הרשת בד״כ יהיה רשום IN.

![Screenshot 2024-02-10 at 1.31.09.png](/img/user/Assets/Screenshot%202024-02-10%20at%201.31.09.png)

בResponse אפשר לראות שגם התווסף תשובת Answers וב RR אפשר לראות שעבור שאלה אחת יש חמש רשומות תשובה. הסיבה לכך היא שלפעמים כתובת דומיין אחת מצביעה לכמה כתובות IP וכך אם שרת אחד נפל יש שכפולים.

![Screenshot 2024-02-10 at 1.32.24.png](/img/user/Assets/Screenshot%202024-02-10%20at%201.32.24.png)

ברשומה של שאילתה יש את השדרות הטריוויאלים אבל נשים לב שיש גם ttl ששדה זה קובע כמה זמן יש לשמור את הרשומה בCache. 

באופן כללי רשומת DNS היא רביעייה מהצורה $RR=(name,type,ttl,addr)$ כאשר מידע נוסף מועיל אבל לא הכרחי.

ה type מתחלק ל4 :
![Screenshot 2024-02-10 at 1.51.16.png](/img/user/Assets/Screenshot%202024-02-10%20at%201.51.16.png)
### הרשמת Domain חדש
כאשר אנחנו מרימים domain חדש צריך לרשום אותו ב DNS registrar. 
כאשר רושמים אותו מייצרים לו גם Name Server רלוונטי שיודע להחזיר את ה IP הרלוונטי ל domain . בעצם הregistrar מייצר שני RRs חדשים ל Top Level Domain Server של $.com$ 
הראשון הוא המיפוי בין הdomain ל NS הרלוונטי, השני הוא הכתובת IP  של הNS

![Screenshot 2024-02-10 at 1.48.01.png](/img/user/Assets/Screenshot%202024-02-10%20at%201.48.01.png)
כל רשומה כזאת נשמרת בcache לTTL זמן כפי שאמרנו. 

### DNS Redirection 
טכניקה שנועדה לפזר עומס על שרתים. בהינתן Domain מסויים, יהיו מספר העתקים שלנו כאשר לכל אחד יש IP שונה. שרת ה DNS מחזיר כתובת IP שונה לצורך פיזור העומס, באמצעות אלגוריתם [Round Robin](https://en.wikipedia.org/wiki/Round-robin_scheduling).  

![Screenshot 2024-02-25 at 2.49.40.png|250](/img/user/Assets/Screenshot%202024-02-25%20at%202.49.40.png)
## HTTP 
Hyper-Text Transfer Protocol. פרוטוקול זה מאפשר לאפליקציות לגשת ולעשות שימוש במשאבי האינטרנט (תמונות, קבצים וכו׳). בפרוטוקול זה כתובת ה URL היא מרכיב הכרחי כדי לקבוע מהו המשאב הרלוונטי שאנחנו רוצים למשוך

![Screenshot 2024-02-10 at 1.55.33.png](/img/user/Assets/Screenshot%202024-02-10%20at%201.55.33.png)
![Pasted image 20240210015713.png](/img/user/Assets/Pasted%20image%2020240210015713.png)

HTTP עובד בעקרון של בקשה ותגובה כלומר הלקוח שולח בקשה לשרת וכאשר היא מתקבלת, השרת ישלח תגובה. בתקשורת HTTP השרת לא יוזם שיח עם הלקוח.

כמו כן חשוב לציין ש HTTP רץ על [[Computer Science/Networks/Transport Layer#TCP\|TCP]] .

![Pasted image 20240210015849.png](/img/user/Assets/Pasted%20image%2020240210015849.png)

### גרסאות HTTP 
ישנם מספר גרסאות ל HTTP שחשוב להכיר:
![Screenshot 2024-02-10 at 2.06.53.png](/img/user/Assets/Screenshot%202024-02-10%20at%202.06.53.png)

__Non-persistent:__
על גבי חיבור TCP בודד ניתן לקבל משאב אחד ואז החיבור נסגר.

__Persistent:__
כמה וכמה בקשות ניתנו לביצוע פר חיבור TCP בודד.

__Pipelining:__
ניתן לשלוח מספר בקשות HTTP לפני שמתקבלת עליהן תשובה __על אותו החיבור__ .
### Format
יש שני סוגי הודעות ל Http: הודעת request והודעת response .
שני הבקשות עוברות בקידוד [[Computer Science/Computer System/ASCII\|ASCII]] .

בקשת request נראת המצורה:
![Screenshot 2024-02-23 at 18.21.04.png](/img/user/Assets/Screenshot%202024-02-23%20at%2018.21.04.png)
נשים לב שה $\text{/r/n}$ בסוף הם אינדיקצייה לכך שהסתיימו הheaders בבקשת http.

![Screenshot 2024-02-24 at 14.27.06.png](/img/user/Assets/Screenshot%202024-02-24%20at%2014.27.06.png)

הresponse נראה מהצורה:
![Screenshot 2024-02-24 at 14.28.15.png](/img/user/Assets/Screenshot%202024-02-24%20at%2014.28.15.png)
### Http Request 
#### Start line
בקשות HTTP הן הודעות שנשלחות על ידי הלקוח כדי ליזום פעולה בשרת. קו ההתחלה שלהם מכיל שלושה אלמנטים:
___HTTP method___
מתאר איזה פעולה הבקשה רוצה לעשות:
`GET`- מבקשת לקבל משאב מסויים.
`HEAD`- מבקשת את אותה תגובה כמו בקשת ה `GET` רק בלי ה body.
`POST`- שליחה של יישות עבור משאב מסויים במערכת, לעתים זאת משנה את ה state שלו או משפיעה על השרת.
`DELETE`- מחיקה של משאב מסויים.
`PUT`-החלפה של משאב מסויים בתוכן הבקשה.
`PATCH`- ביצוע מודיפיקציה של משאב בשרת.

___Request target___
בדרך כלל זה URL או נתיב אבסולוטי שמכיל בתוכו queries, פורט וכו׳.
בעצם זה יכול להיות כל נתיב שהוא בעצם מורכב מהמבנה המלא של [URL](https://developer.mozilla.org/en-US/docs/Learn/Common_questions/Web_mechanics/What_is_a_URL) 
![Pasted image 20230727121230.png](/img/user/Assets/Pasted%20image%2020230727121230.png)
___HTTP version___
הגרסה קובעת את המבנה של שאר ההודעה וגם כדי לדעת כיצד לבנות את התגובה.
#### Headers
 כותרות HTTP מייצרות בקשה תחת אותו מבנה בסיסי של Header HTTP: מחרוזת לא תלוית רישיות ואחריה נקודתיים (':') וערך שהמבנה שלו תלוי בHeader. הכותרת כולה, כולל הערך, מורכבת משורה אחת בודדת, שיכולה להיות ארוכה למדי.
 
__זה סוג של metadata על הבקשה.__
![Pasted image 20230727120750.png](/img/user/Assets/Pasted%20image%2020230727120750.png)
#### Body
החלק האחרון של הבקשה הוא הגוף שלה. לא לכל הבקשות יש אחת: בקשות שמביאות משאבים, כמו GET, HEAD, DELETE או OPTIONS, בדרך כלל אינן זקוקות למשאבים כאלה. חלק מהבקשות שולחות נתונים לשרת על מנת לעדכן אותם: כפי שקורה לעתים קרובות בבקשות POST (המכילות נתוני טופס HTML).
### HTTP Response
כפי שאמרנו המבנה הוא דומה לRequest. 

___Status line___
שורת ההתחלה של תגובת HTTP, הנקראת שורת המצב, מכילה את המידע הבא:
1. גרסה של הפרוטוקול, בד״כ `HTTP/1.1`
2. סטטוס קוד שמעיד על הצלחה או כשלון. ישנן קונבנציות הקשורות לקודים האלה למשל:
	 $200-299$ מייצג הצלחה
	 $400-499$ מייצג שגיאה הקשורה בצד client. 
	 $500-599$ זה שגיאה בצד שרת. (505 למשל זה גרסה שונה של Http)
	 301 - האובייקט שחיפשנו זז בצד שרת למיקום אחר שיפורט בהמשך בheader ה location.

___Headers___
מבנה זהה לחלוטין של headers בבקשת http. ההבדל היחיד הוא בקונטקסט שיש לheaders האלה כלומר מה המשמעות שלהם.

![Pasted image 20230727121718.png](/img/user/Assets/Pasted%20image%2020230727121718.png)

___Body___
באופן דומה ל HTTP Request. מכילות מידע החוזר מבקשה. הרבה פעמים אנחנו נראה את זה בבקשות מסוג GET.

### Coockies
באינטרנט, עוגייה היא מחרוזת אותיות או מספרים, המשמשת לאימות, למעקב ולאגירת מידע על אודות גולש באתר אינטרנט, כגון שמירת העדפות המשתמש. העוגייה מייצגת מצב מסוים של גלישה באתר או שימוש באפליקציה. לעיתים, גם אתרים שאינם האתר שיצר את העוגייה יכולים להשתמש בה.

העוגייה נוצרת על ידי השרת שמעביר אותה לדפדפן ששומר אותה בזיכרון המחשב. המחרוזת מוחזרת חזרה לשרת בכל פעם שהדפדפן יוצר קשר עם השרת וכך למעשה יכול השרת לזהות את המשתמש ולאחזר מידע שנשמר בין שיחות שונות.

![Pasted image 20240224144459.png|350](/img/user/Assets/Pasted%20image%2020240224144459.png)


הדפדפן שומר את העוגיות בקובץ key-value כאשר ה key הוא הdomain והvalues הם הcoockies ששמרת עבור אותו domain. 

![Screenshot 2024-02-24 at 15.49.54.png|350](/img/user/Assets/Screenshot%202024-02-24%20at%2015.49.54.png)

### Http cache
ל Http יש מנגנון Cache בצד הלקוח שמאפשר לדעת האם יש צורך להביא משאבים כבדים מהשרת או לטעון אותם ישירות מהcache למשל על ידי שימור בפרמטר ה last modified.
![Screenshot 2024-02-24 at 16.00.35.png|350](/img/user/Assets/Screenshot%202024-02-24%20at%2016.00.35.png)

ניתן לראות שהשרת יחזיר 304 שזה אומר שהמידע לא השתנה אם שלחנו בקשה עבור משאב שנמצא במטמון בפרק זמן קצר מדי.

היתרון המשמעותי של זה הוא שניתן לחסוך זמן יקר בטעינת משאבים באתר על ידי שימוש במטמון שנמצא קרוב יותר למחשב הלקוח מאשר השרת המקומי.

כמו כן- גם אם המטמון של הresponse שמור בצד שרת עדיין השרת לא צריך לבצע עיבוד לבקשה.

באמצעות הפרמטר Cache-Control נוכל להגביל את זמן השמירה של מידע במטמון וגם לקבוע האם יש צורך בשימוש במטמון בכלל.
#### סוגי Cache 
ישנם שני סוגים עיקריים של cache :
__private__: שמשויך ללקוח לספציפי (מטמון של דפדפן). מטמון כזה יכול לשמור בתוכו response שמיועד ללקוח ספציפי.

אם נרצה לשמור מידע במטמון פרטי נוכל לציין זאת באמצעות הוספת הheader 

```HTTP
Cache-Control: private
```

__shared__: מטמון שממוקם בין הלקוח לשרת ויכול לשמור responses שיכולים להיות משותפים בין מספר משתמשים. אפשר לחלק אותו לשניים, Proxy cache או managed cache .
### Proxy 
המטרה של Proxy Server היא לספק בקשות לקוח מבלי לערב את השרת המקורי. במילים אחרות, שרת שתפקידו העיקרי לספק גישה מהירה למשאבים חיצוניים ברשת מחשבים.

הסוואת כתובת ה-IP מתאפשרת על ידי חיבור לשרת פרוקסי שדרכו כל חיבורי האינטרנט עוברים (הנתונים נשלחים אליו וממנו אל השרת ומן השרת אליו ועד למשתמש) כפי שניתן לראות בתמונה.

תפקידו העיקרי של שרת הפרוקסי מתאפשר באמצעות תוכנה השומרת בזיכרון המטמון שלו עותקים של דפי אינטרנט ומאפשרת גישה מהירה אליהם מהמחשבים המחוברים לפרוקסי. בחלק מהמקרים משמש הפרוקסי כנקודת הפרדה וביקורת בין רשת המחשבים הפנימית של הארגון אליו הוא שייך לבין העולם החיצוני.

הוא מאפשר מעקב, חסימה או שינוי לדפי HTML על פי מדיניות הארגון בענייני אבטחת מידע ותכני מידע קבילים (אפשר, למשל, לחסום אתרים פורנוגרפיים). יש מקרים שהוא משמש למימוש SSO (מסיר את הצורך בהכנסת שם לכל אפליקציה שונה) ולהוספת הגנות לדפי הארגון על פי הרשאת המשתמש.

![Screenshot 2024-02-25 at 2.30.51.png](/img/user/Assets/Screenshot%202024-02-25%20at%202.30.51.png)

__סוגי Proxy:__
	1) Regular Proxy
	2) Transparent Proxy - הלקוח לא מכיר את ה Proxy הזה, הוא מפענח פקטות ומשתמש בהן בהתאם.
	3) Reverse proxy- מיועד לצד השרת , מסתיר את השרת והטכנולוגיה של השרת, מבצע בעיקר cache ו load balancing בשביל [[Scaleability\|Scaleability]].
 
### HTTP calculations
בחלק זה נראה מספר שאלות חישוב שניתן לעשות מעל HTTP.

__שאלה 1:__
![Screenshot 2024-02-27 at 0.14.14.png](/img/user/Assets/Screenshot%202024-02-27%20at%200.14.14.png)

מכיוון שאליס עובדת בhttp1.0 אזי מדובר על חיבור שהוא ברירת מחדל לא persistent.

נשים לב: תמיד דגל ה ACK דולק בכל החבילות (למעט הראשונה של ה SYN, ובהתאם ערך ה ACK number יהיה הכי עדכני). לא תמיד נקפיד על הצגה של זה בתרשימים הבאים.

נשים לב שהדפדפן של אליס מעולם לא ניגש לאתר של בוב אבל שרת ה DNS המקומי כן ניגש. כלומר כשנשלח אליו בקשת DNS הוא לא יצטרך ללכת להירכייה ומיד יוכל להחזיר תשובה.

![Screenshot 2024-02-27 at 0.18.11.png](/img/user/Assets/Screenshot%202024-02-27%20at%200.18.11.png)
נשים לב שDNS הוא מעל UDP כפי שאמרנו.

כעת יתחיל חיבור TCP בין אליס ובוב כיוון ש HTTP הוא פרוטוקול מעל TCP ואליס שולחת בקשת GET כדי לקבל את עמוד האינטרנט. כמו כן כיוון שנתון שבקשה בודדת הייתה קטנה מ MSS כל תהליך ה request ו response יהיה בסגמנט אחד בלבד לכל שלב.
לבסוף נוכל לסגור את חיבור הTCP לאחר שהבקשה הושלמה.
![Screenshot 2024-02-27 at 0.21.08.png](/img/user/Assets/Screenshot%202024-02-27%20at%200.21.08.png)

__לא סיימנו__, כיוון שאתר האינטרנט מכיל גם תמונה אחת הדפדפן צריך להוריד את הasset בבקשת GET נוספת ולכן יפתח חיבור TCP חדש.
![Screenshot 2024-02-27 at 0.22.45.png](/img/user/Assets/Screenshot%202024-02-27%20at%200.22.45.png)

__שאלה 2:__
![Screenshot 2024-02-27 at 0.25.11.png](/img/user/Assets/Screenshot%202024-02-27%20at%200.25.11.png)
נתון שהשהיית ההתפשטות מהclient ל server היא $10^{-3}$.
כיוון שניתן להתעלם מהשהיית ההתפשטות של תחיליות ושל הבקשה בפרט. לכן אין צורך לחשב את השהיית השידור מהלקוח לראוטר ומשם לשרת. אפשר לחשב ישירות את ההשהייה מהלקוח לשרת
 
![Screenshot 2024-02-27 at 0.49.46.png](/img/user/Assets/Screenshot%202024-02-27%20at%200.49.46.png)

ניתן לראות ששלב הhandshake ושליחת הבקשה לוקח 3 השהיות כלומר $3 \cdot 10^{-3}$ שניות. 

כעת נשים לב שה MSS=1KB אבל הresponse הוא קובץ בגודל 3KB. 

נשים לב שלפי נתוני ההתפשטות של כל ערוץ. להעביר MSS אחד בתווך בין השרת לראוטר ייקח $10^{-3}$ שניות. ולהעביר MSS אחד בערוץ בין הראוטר ללקוח זה פי 4 מזה ולכן זה יהיה $4\cdot 10^{-3}$ שניות. לכן להעביר MSS אחד מהשרת ללקוח הוא תהליך שלוקח $5\cdot 10^{-3}$ שניות. אפשר להוסיף עוד אלפית שניה בשביל לדווח ack לשרת ולכן כל התהליך יהיה $6\cdot 10^{-3}$ שניות.

התהליך הזה חוזר על עצמו 3 פעמים אחד אחרי השני (בגלל שאנחנו בstore and forward) וסך הכל התהליך יסתיים לאחר 21 אלפית השנייה.

__שאלה 3:__
![Screenshot 2024-02-27 at 1.03.13.png](/img/user/Assets/Screenshot%202024-02-27%20at%201.03.13.png)

נשים לב שכעת פרוטוקול DNS הולך ״לעבוד קשה״ בגלל שהcache ריק. הלקוח ברשת A ניגש לשרת הפרוקסי ולאחר מכן ניגש לlocal resolver שמשם יבצע את שרשרת ה DNS הרלוונטית למשיכת הip. 
![Screenshot 2024-02-27 at 1.37.39.png](/img/user/Assets/Screenshot%202024-02-27%20at%201.37.39.png)

 כעת הפרוקסי יבצע פנייה ל local resolver בכוונה למצוא את הdomain וכן הלאה נמשיך בשרשרת פניות ל ns servers כדי למצוא את ה ip. נזכיר ש DNS לא עובד רקורסיבי אלא סדרתי ולכן השרת com יחזיר תשובה ל B.com לresolver וכן הלאה. לבסוף הresolver יחזיר את התשובה ל proxy.

![Screenshot 2024-02-27 at 1.44.01.png](/img/user/Assets/Screenshot%202024-02-27%20at%201.44.01.png)

לאחר שכל זה קרה, יתבצע חיבור TCP נוסף בין ה proxy לבין ה web server לקבלת הדף ושמירה ב cache.

![Screenshot 2024-02-27 at 1.45.00.png](/img/user/Assets/Screenshot%202024-02-27%20at%201.45.00.png)

_שאלה 3.2_
![Screenshot 2024-02-27 at 1.45.50.png](/img/user/Assets/Screenshot%202024-02-27%20at%201.45.50.png)

יש 10 חבילות שנשלחות באינטרנט ועוד 6 חבילות באותה הרשת ולכן 

$$6\cdot 50ms+10\cdot 500ms = 5300ms $$

__שאלה 4:__
![Pasted image 20240227015127.png](/img/user/Assets/Pasted%20image%2020240227015127.png)

יש $N$ שרתי DNS שהיה צריך לפנות אליהם וזה לקחת $RTT_{1}+\dots+RTT_{n }$ . כעת חיבור הtcp , שליחת Syn וקבלת Ack עליו לוקחת $RTT_{0}$ ושליחת Ack וקבלת התשובה לוקח עוד $RTT_{0}$ ולכן 

$$2RTT_{0}+\sum\limits_{i=1}^{N} RTT_{i} $$

__שאלה 5:__
![Pasted image 20240227021546.png](/img/user/Assets/Pasted%20image%2020240227021546.png)
![Pasted image 20240227021745.png](/img/user/Assets/Pasted%20image%2020240227021745.png)

השהיית ההתפשטות נתונה לנו לכן צריך לחשב רק את השהיית השידור ונקבל 

$$\displaylines{
d_{t_{S\to R_{2}}}= \frac{20Kb}{100Mbps}=0.2ms\\
d_{t_{R_{2}\to R_{1}}}= \frac{20Kb}{25Mbps}=0.8ms\\
d_{t_{R_{1}\to C}}= \frac{20Kb}{1Gbps}= 0.02ms\\
d_{E 2E}= 250ms+1.02ms= 251.02ms
}$$

![Screenshot 2024-02-27 at 2.24.33.png](/img/user/Assets/Screenshot%202024-02-27%20at%202.24.33.png)
כגודל הערוץ המינימלי 25Mbps .

![Screenshot 2024-02-27 at 2.27.15.png](/img/user/Assets/Screenshot%202024-02-27%20at%202.27.15.png)
נחשב ממוצע משוקלל :

$$0.6*1Gbps + 0.4*25Mbps=610Mbps$$

__שאלה 6:__
![Screenshot 2024-02-27 at 2.30.22.png](/img/user/Assets/Screenshot%202024-02-27%20at%202.30.22.png)
![Screenshot 2024-02-27 at 2.41.34.png](/img/user/Assets/Screenshot%202024-02-27%20at%202.41.34.png)

## CDN 
Content Delivery Network היא רשת של שרתים שמאפשר העלאה מהירה יותר של דפי אינטרנט כאשר הן עושות שימוש בהמון data.

אם לא היינו משתמשים בשירות הזה כל הלקוחות שמשתמשים בשירות שלנו ניגשים לאותו שרת. המנגנון הזה נתון להמון בעיות, החל מהעובדה שלקוחות מסוימים יחוו את טעינת האתר בצורה איטית יותר או שהשרת עלול לקרוס ואין לו גיבוי.

![Screenshot 2024-02-25 at 2.51.58.png](/img/user/Assets/Screenshot%202024-02-25%20at%202.51.58.png)

חברות רבות שמציעות שירותי CDN מציעות אלטרנטיבה לרכישה של שרתים מסביב לעולם כדי לתקן את הבעיות האלה. 
החברות הנ״ל שמו בכל מיני אזורים שרת שנקרא Edge server. הלקוחות פונים לאחד מהשרתים הקרובים אליהם באמצעות קח שהן מתלבשות על חוות שרתים של ספקי האינטרנט באזורים השונים.
השרתים האלה מהווים מנגנון של Cache עבור השרת שלנו. 

![Screenshot 2024-02-25 at 2.53.56.png](/img/user/Assets/Screenshot%202024-02-25%20at%202.53.56.png)

## SMTP
Simple Mail Transfer Protocol הוא פרוטוקול שכבת האפליקצייה המכיל 3 רכיבים עיקריים
1) user agents
2) mail servers
3) simple mail transfer protocol 

![Screenshot 2024-02-25 at 23.16.53.png|300](/img/user/Assets/Screenshot%202024-02-25%20at%2023.16.53.png)

### User Agent
* עונה גם לשם mail reader
* מיועד לעריכה קריאה ושליחה של הודעות מייל.
* תוכנות רבות מהוות user agent לפרוטוקול למשל אפליקציית Outlook, Gmail וכו׳
* הודעות יוצאות ונכנסות מאוחסנות בשרת. 

כדי לדחוף מיילים מהuser agent לשרת נשתמש ב SMTP. 
הייחודיות בפרוטוקול SMTP היא היכולת להעביר מיילים גם בין "domains" שונים, כלומר שאינם קשורים לאותו שרת. 

_נשים לב:_ SMTP משמש למשלוח דואר אלקטרוני מuser agent ובין שרתים שונים, עד שיגיע לשרת היעד, אך אינו מאפשר למשתמש לשלוף את הודעות הדואר המיועדות אליו מן השרת. קיימים פרוטוקולים אחרים המיועדים לשליפה של הודעות דואר, כגון POP3 ו-IMAP.

SMTP עובר מעל TCP ומשתמש בדרך כלל בפורט 25. פורט לקבלת נתונים הוא פורט 587.

### Flow
1) אליס משתמשת ב user agent כדי לנסח הודעה עבור bob@someschool.edu.
2) אליס שולחת הודעה לשרת המייל שלה , שם הוא נמצא ב message queue.
3) ״צד הלקוח״ של שרת הSMTP הנ״ל פותח חיבור TCP לשרת המייל של בוב.
4) SMTP client שולח את ההודעה של אליס על גבי TCP.
5) שרת המייל של בוב ממקם את ההודעה של בוב ב mailbox.
6) בוב מושך מהשרת את ההודעות שלו (בעזרת פרוטוקול אחר או בעזרת ה web-based mail).

![Screenshot 2024-02-25 at 23.31.57.png](/img/user/Assets/Screenshot%202024-02-25%20at%2023.31.57.png)

נשים לב שאם אליס ובוב היו באותו שרת web שלבים 4 5 ו6 לא היו רלוונטים אלא שהשרת היה מיד שם את ההודעה בתיבה של בוב והוא היה מושך את זה. 

נסתכל על Flow של תקשורת SMTP לדוגמה-
![Screenshot 2024-02-26 at 0.12.02.png](/img/user/Assets/Screenshot%202024-02-26%20at%200.12.02.png)

כאן ניתן לראות את התקשורת רק ברמת האפליקציה (בלי [[Computer Science/Networks/Transport Layer#TCP\|TCP]]). ניתן לראות שהשרת שולח הודעה ראשונה ללקוח עם קוד 220 ו״מציג את עצמו״. לאחר שהלקוח גם מציג את עצמו עם הודעת HELO ואת ה״דומיין״ שלו. ניתן לראות שהשרת שוב מגיב ללקוח עם קוד 250 והודעת Hello. נשים לב שההודעה השנייה, HELO נראת כאילו היא עם מעין שגיאת כתיב אך זה הקונבנציה לשלב שבו השרת השולח מציג את עצמו לשרת המקבל. השרת המקבל יסכים לכל שם שישלח במסגרת הודעה זאת. לעתים ניתן להתקל גם בהודעה EHLO שזה הרחבה של HELO. אם הפקודה הזאת נשלחת מהלקוח השרת צריך להגיב עם מידע נוסף שהוא תומך בו.

לאחר מכן הלקוח שולח לשרת הודעת MAIL FROM. השרת מגיב ב 250 (כמו מקודם) ומאשר את המייל של השולח.

כעת הלקוח שולח לשרת את שם הנמען עם הודעה RCPT TO. השרת מגיב ללקוח עם 250 ומאשר את הנמען (אם היו כמה נמענים השורות האלה היו חוזרות על עצמן כמספר הנמענים).

כעת הלקוח שולח לשרת הודעת DATA כדי להכין את השרת לקבלת מידע (נגמר מידע ה״מעטפה״). השרת מגיב בהודעת 354 ומבקש לסיים את המייל עם הודעת ״.״ בסוף בשורה נפרדת. 

הלקוח לאחר מכן שולח את הdata עם נקודה בסוף כמבוקש. השרת מדווח 250 שהוא קיבל את ההודעה וכיוון שהלקוח סיים הוא שולח QUIT והשרת מגיב בהודעת 221 וסוגר את החיבור. 

__נסתכל על דוגמה נוספת:__
![Screenshot 2024-02-26 at 0.27.26.png](/img/user/Assets/Screenshot%202024-02-26%20at%200.27.26.png)
ניתן לראות את שלב ה handshake בשני השכבות גם בתעבורה וגם באפליקצייה. 
השלב הבא הוא שלב ה envelope.נשים לב שהמייל המוצמד בהודעת MAIL FROM בשלב המעטפה הוא המייל שאליו השרת ידווח שגיאה במקרה ולא ניתן להעביר את ההודעה.

כאן בשלב ה message הלקוח שולח שתי הודעות דיווח נוספות של from ו to וכאן יש שני נמענים ורק לאחר מכן נשלח הdata הנוסף. הפורמט הזה הוא הפורמט הרשמי של [RFC822](https://datatracker.ietf.org/doc/html/rfc822). ניתן לראות שאומנם יש כאן עוד נמען אך השרת הנ״ל מתעסק ב b.com ולכן הוא לא מתעסק בזה. 

![Pasted image 20240226004153.png](/img/user/Assets/Pasted%20image%2020240226004153.png)

כאן ניתן לראות דוגמה שבה המידע הנוסף (המידע ב Cc) כן היה רלוונטי עבור השרת הנ״ל ולכן הוא גם קיבלת הודעת RCPT נוספת עבור מייל זה (בשניהם הדומיין הוא example.com).

![Screenshot 2024-02-26 at 0.48.09.png](/img/user/Assets/Screenshot%202024-02-26%20at%200.48.09.png)
כאן גם יש שני נמענים רק שהפעם אחד הנמענים הוא נסתר ולכן לא נמצא כחלק מהData. כמו כן בסיום ההודעה לא נסגר החיבור אלא נשלח הודעה חדשה אל נמען אחר ב sponge.com. 
### POP3 
פרוטוקול משיכת המיילים בצד הלקוח. 

![Screenshot 2024-02-26 at 0.51.59.png|300](/img/user/Assets/Screenshot%202024-02-26%20at%200.51.59.png)

השלב הראשון בflow התקשורת בפרוטוקול זה הוא שלח ה authorization. בשלב זה הלקוח שולח את המשתמש ( user bob ) ולאחר מכן את הסיסמה (pass hungry) והשרת מגיב בהודעת $+OK$ או ב $-ERR$ .

השלב השני נקרא שלב הtransaction, בשלב זה הלקוח מבקש לקבל רשימת הודעות חדשות באמצעות הפקודה list. השרת יגיב רשימה של tuple של מספר הודעה עם הגודל שלה ויסיים כאשר ישלח את התו ״.״ בשורה ריקה.

לאחר מכן הלקוח יכול להחליט להשתמש בפקודות מסוימות על הודעות מהרשימה למשל dele 1 תמחק את הודעה 1 מהרשימה ו retr 2 תשלוף את המידע מההודעה לפי המספר הודעה.

פרוטוקול POP3 וקודמיו תוכננו במטרה לאפשר למשתמשים שאין להם חיבור-קבוע לשרת הדואר, דוגמת משתמשי מודם חיוג או [ADSL](https://he.wikipedia.org/wiki/ADSL), גישה לדואר האלקטרוני שלהם. במרבית המקרים, צד הלקוח מתחבר אל השרת, מוריד ממנו את ההודעות במלואן בסדר שבו התקבלו, ושומר אותן על מחשבו. לאחר מכן ההודעות נמחקות מהשרת. הפרוטוקול תומך באפשרות (אם כי השימוש בה הוא לא-נפוץ) להשאיר עותק מן ההודעה המקורית על השרת. בצורה זו יכול המשתמש לקרוא את הדואר שלו מכמה מקומות וגם מכמה תוכנות לקוח שונות. לכן POP3 הוא stateless לאורך הsession, הוא לא שומר את המידע בשרת. 

__פרוטוקול נוסף להעברת דואר הוא פרוטוקול IMAP.__ זהו פרוטוקול חדש יותר ובעל מגוון פונקציות נוספות, כגון אימות מוצפן, הפרדת הדואר לתיקיות-משנה, הפרדה בין כותרי ההודעה לגוף, ועוד. מאחר שזהו פרוטוקול מורכב הרבה יותר, הוא נפוץ פחות ורוב ספקיות האינטרנט אינן מאפשרות גישת IMAP ללקוחותיהן.

בעוד שליחה של דואר אלקטרוני או העברת דואר בין שרתים מתבצעת באמצעות פרוטוקול SMTP והרחבותיו, קריאת דואר על ידי הלקוח תתבצע באמצעות פרוטוקול POP3 או IMAP.

![Screenshot 2024-02-26 at 0.59.26.png](/img/user/Assets/Screenshot%202024-02-26%20at%200.59.26.png)

### SMTP calculations

![Pasted image 20240307120918.png](/img/user/Assets/Pasted%20image%2020240307120918.png)

קודם כל צריך לדעת מיהו שרת המיילים של israblof.com . לשם כך השולח ירצה לשאול את שרת ה DNS המקומי של הרשת שלו. כיוון שאפשר להניח שיש במטמון את רשומות הNS של COM אז השרת dns המקומי יעבור את השאילתה ״מיהו שרת ה MX של israblof.com?״ אל שרת ה NS של com מבלי לחפש אותו. שרת זה מחזיר את הip של שרת הNS של israblof.com אל שרת הדומיין המקומי והוא ילך לשאול את שרת זה את הכתובת של שרת ה MX המתאים.

כפי שציינו שרתי DNS יודעים לעבור עם priorities ל דומיין וכדי להוריד את העומס השרת ns.israblof.com יחזיר קודם כל העדיפות גבוהה את הכתובת של שרת ה MX : mail.MXrUS.com . ולכן כשהdomain הזה יחזור לשרת הlocal DNS הוא יחזיר את הdomain שאותו יש לחפש (מבלי לצרף הת הIP כמו במקרה של ns.com) ל sender.com . מיד תשלח בקשה נוספת כדי לחפש את הדומיים של שרת הMX והתהליך יעבור שוב דרך ns.com ויוחזר 5.5.6.6 שזה כתובת שרתי ה dns של MXrUS. לאחר פנייה אליו, הוא יחזיר את כתובת ה ip של של המיילים שלהם שתומך בשרת של israblof. כעת אפשר להתחיל לבצע חיבור SMTP לשרת המיילים הזה

![Screenshot 2024-03-07 at 12.11.39.png](/img/user/Assets/Screenshot%202024-03-07%20at%2012.11.39.png)

כדי לבדוק את אמינות המידע שרת המיילים שולח בקשת DNS עם ה ip של השולח כדי לוודא שהדומיין הוא אכן שרת מיילים תקין.

מתבצע כעת חיבור SMTP בין שרת המיילים של MXrUS אל mail.israblof וגם הוא מבצע את אותה בדיקת אמינות. והמידע מגיע ליעד.