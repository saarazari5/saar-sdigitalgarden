---
{"dateCreated":"2024-05-17 02:52","tags":["networks","network_security"],"pageDirection":"rtl","dg-publish":true,"permalink":"/computer-science/networks/network-security/encryption/","dgPassFrontmatter":true}
---

# Encryption
הצפנת המידע היא טכניקה המאפשרת סודיות של המידע העובר ברשת והגנה עליו מפני גורמים שמנסים לדלות את המידע הזה ברשת.

נשים לב שהצפנה מטרתה סודיות אבל היא לא מבטיחה יושרה של המידע כלומר לא בטוח שמי שהצפין את המידע זה הצד השולח, את זה אין איך לדעת.

__Keyless Encryption Scheme__
__הגדרה__: הצפנה היא פונקציה Enc שמקבלת $p$ , טקסט רגיל ומחזירה $c$ טקסט מוצפן. $c$ לא מכיל שום מידע על הטקסט המקורי
__הגדרה:__ פונקציית הפענוח (decryption) היא פונקציה Dec שמקבלת $c$ ומחזירה $p$ כלומר מקבלת טקסט מוצפן ומחזירה plain text כלומר $p'$. 
__סכמת ההצפנה:__ מכילה שני אלגוריתמים $(Enc,Dec)$, המקיימים נכונות כלומר $Dec(Enc(p))=p$ .


>[!note] הצפנת קיסר
>הצפנת קיסר היא שיטה הסטורית של הצפנה שכבר לא נפוצה היום והיא סך הכל ביצעה shift לתווים לפי מספר מסויים. למשל, אם ערך הshift הוא 3 והתו במחרוזת הוא a אז במחרוזת המוצפנה הוא יהיה $a \to b \to c \to d$ 
>![Pasted image 20240517030242.png|400](/img/user/Assets/Pasted%20image%2020240517030242.png) 
>אם נסתכל על סכמת ההצפנה נקבל 
>![Pasted image 20240517030436.png|400](/img/user/Assets/Pasted%20image%2020240517030436.png)

__קונבנציה__
*  Alice , Bob , Charlie, Carol - קונבנצייה לצדדים בתקשורת שהם ״תמימים״
* אויב מסוג off path ייקרא Oscar.
* אויב מסוג מאזין ייקרא Eve 
* Man in the Middle ייקרא Mallory

כאשר מתעסקים בהצפנה חשוב גם להבין מהי חשיבות ההצפנה ועם איזה בעיות נצטרך להתמודד ללא הצפנה:

1) Off-path - מאזין לתקשורת בין Alice ו Bob __ומדמה__ את הצד השולח.
2) Eavesdropper - מאזין לתקשורת ומקבל עותק של המידע שנשלח בתקשורת.
3) Man in the Middle - לא רק מקבל עותק של המידע אלא המידע עובר דרכו (!) והוא יכול להחליט האם להעביר את המידע שהתקבל או להעביר מידע חדש לחלוטין וכו׳. אפשר להסתכל על זה כמו מעין proxy זדוני...

## Kerckhoffs' principle 
העקרון הזה יוצא מהנחה שתמיד ניתן לדעת את סכמת ההצפנה ולפיכך תמיד ניתן לשבור אותה. 
__העקרון של קרקהוף-__ סכמת הצפנה תהיה בטוחה כל עוד המפתחות של ההצפנה נשארים סודיים (גם אם האלגוריתם של ההצפנה ידוע).
אם הולכים על ההצפנה הזאת אז ההגדרה ממקודם אינה הצפנה שניתן להשתמש בה.

## Symmetric Encryption
סכמת הצפנה סימטרית מוגדרת על ידי (Enc, Dec) כמו מקודם רק שהפעם הקלט לפונקציות יכלול בתוכו מפתח k. לכן ההצפנה נקראת סימטרית כי ערך המפתח k הוא זהה גם בצד המצפין וגם בצד המפרש. כלומר Enc(k, p) = c וגם $Dec(k,c) = p$.

באופן פורמלי נגדיר את סכמת ההצפנה הסימטרית כ $\varepsilon = (KeyGen, Enc, Dec)$ כאשר KeyGen היא פונקציית ההצפנה ו $k\in \text{{Keygen}}$.

אם ניקח את הסכמה הזאת ונפעיל אותה על הצפנת קיסר נקבל 
![Screenshot 2024-05-17 at 3.19.17.png|400](/img/user/Assets/Screenshot%202024-05-17%20at%203.19.17.png)

__האם שיפרנו את הצפנת קיסר על ידי הוספת המפתח?__ לא, בגלל שהתוצאה חסומה בערך קבוע 26 עדיין ניתן לפענח את ההצפנה. מרחב הערכים שkey יכול לקבל במקרה הזה הוא קטן. 

__צופן החלפה__
Monoalphabetic substitution cipher הוא ההכללה של הצפנת קיסר שקבענו מקודם והיא מחליפה בין תווים לאו דווקא על ידי פונקצית shift אלא על ידי פונקצייה שלמה אחרת. 

![Screenshot 2024-05-17 at 3.23.20.png](/img/user/Assets/Screenshot%202024-05-17%20at%203.23.20.png)

במקרה הזה אנחנו משפרים מאוד את מרחב הערכים של k ביחס להצפנת קיסר. כעת מרחב הערכים של מפתח ההצפנה (שהוא טבלת המיפוי)  יהיה $26!$ וכבר פתרון brute force הוא לא יעיל בכלל. האם ניתן לשבור את הצופן בלי לנסות את כל האופציות? כן, [[Computer Science/Algorithms/probability algorithms basics\|אלגוריתמיים הסתברותיים]] על התווים השכיחים ביותר בשפה האנגלית E,T,A,O,I,N וכו׳ יכולים לצמצם משמעותית את הבדיקות. כמובן שצריך להניח שהתוקף יודע את ההתפלגויות בטקסטים שאנו רוצים להצפין בצורה מושלמת כי אנחנו מניחים לפי קרקהוף שהכל ידוע פרט למפתחות. כעת כשההתפלגויות האלה ידועות הוא יכול פשוט לחפש את התו עם השכיחות הכי גבוהה במחרוזת המוצפנת ולהחליף אותו בתו עם השכיחות הכי גבוהה בהתפלגות וכן הלאה..


__הצפנת ויגר__ 
נבחן הצפנה נוספת ונבחן האם טווח המפתחות שלה טוב. 
Vigenere cipher הולך כך:

1. בחירת מפתח אקראי - רצף תווים אקראי
2. שרשור המפתח לעצמו
	*  להמשיך לשרשר עד שהאורך של המפתח זהה לאורך של המחרוזת (תוך התעלמות מתווים שקופים)
3. לבצע shift על התו ה i במחרוזת לפי הערך של התו ה i במפתח.

![Screenshot 2024-05-17 at 11.58.26.png](/img/user/Assets/Screenshot%202024-05-17%20at%2011.58.26.png)

כאן ניתן לראות שהמילה הראשונית הייתה lemon. כדי לחשב למשל את הערך החדש של האות t מבצעים סכימה עם הערך של l (האינדקס בabc, כלומר 11) כשמחברים ומבצעים %26 מקבלים 4 שזה התו e.

על פניו נשמע מבטיח, אבל נשים לב שהעובדה שהרצף חוזר על עצמו באיזשהו שלב מאפשרת לנו לקבל מספרים שאורך המפתח המקורי יהווה מחלק שלהם

![Screenshot 2024-05-17 at 12.04.09.png](/img/user/Assets/Screenshot%202024-05-17%20at%2012.04.09.png)

התוקף מצא שתי מילים זהות בטקסט המוצפן (עדיפות שיהיו באורך ראשוני כמו 3) במקרה זה, $fvr$. הוא בדק את מספר התווים בין התו הראשון במפתח המתאים ל f הראשון במחרוזת המוצפנת ובין התו הבא המתאים במפתח נקבל הפרש 10. אם נעשה את זה במצבים נוספים נקבל את ההפרש 50
![Screenshot 2024-05-17 at 12.08.32.png](/img/user/Assets/Screenshot%202024-05-17%20at%2012.08.32.png)

נשים לב שהעובדה שהתווים האלה זהים בהצפנה היא בגלל שגם המילים ב p היו זהות אבל גם המפתח חזר על עצמו בקפיצות של האורך שלו ולכן קיבלנו רצף זהה. כלומר אפשר לחשוד שאורך המחרוזת המקורית הוא מחלק משותף של 50 ו 10 כלומר או 2 או 5 או 10.
השיטה הזאת נקראת __Kasiski method__. כעת אם גילינו שהמפתח הוא באורך 5 נוכל לבצע בנייה של שכיחויות לפי קפיצות של אורך המחרוזת.

![Screenshot 2024-05-17 at 12.12.47.png](/img/user/Assets/Screenshot%202024-05-17%20at%2012.12.47.png)

e מופיע הכי הרבה פעמים במקרה הזה. כיוון שאפשר להניח שהתפלגות התווים ידועה בתווים של הטקסט המקורי נוכל לבצע התאמה בין התו e לתו שמופיע הכי הרבה פעמים בטקסט המקורי.