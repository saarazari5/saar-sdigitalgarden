---
{"dateCreated":"2024-02-27 13:01","tags":["networks"],"pageDirection":"rtl","dg-publish":true,"permalink":"/computer-science/networks/network-layer/","dgPassFrontmatter":true}
---

# שכבת הרשת
תפקיד שכבת הרשת הוא לשנע segment מהרכיב השולח לרכיב המקבל.  

__השולח__ - מייצר datagram מה segment ומעביר ל link layer. 
__המקבל__ - מעביר את הsegment ל[[Computer Science/Networks/Transport Layer\|Transport Layer]] .

התפקיד של שכבת הרשת הוא לא בידיוק להעביר למחשב המקבל אלא לרשת שבה נמצא המחשב המקבל , [[Link Layer\|Link Layer]] אחרי להעביר את המידע למחשב המתאים ברשת המקומית.

ל[[Computer Science/Networks/Network Devices\|ראוטר]] יש תפקיד מרכזי בשכבה זו:
	* הוא בודק את כל שדות ה headers בכל ה IP datagrams.
	* משנע datagrams מ input ports ל output ports כדי שיוכל להעביר אותם את כל הדרך עד לרשת המתאימה
	![Screenshot 2024-03-06 at 20.07.49.png](/img/user/Assets/Screenshot%202024-03-06%20at%2020.07.49.png)
ישנן שתי פונקציות עיקריות של שכבת הרשת
forwarding- שינוע פקטות מראוטר אחד לראוטר הבא בתור.
routing - קביעת המסלול מהשולח ליעד.

![Screenshot 2024-03-06 at 22.30.51.png|350](/img/user/Assets/Screenshot%202024-03-06%20at%2022.30.51.png)

על שכבת הרשת נסתכל בשני מישורים עיקריים
Data plane - כאשר הראוטר מקבל חבילה הוא קובע כיצד ה datagram המתקבל מinput כלשהו יעבור ל output port של הראוטר הבא.

![Screenshot 2024-03-06 at 22.33.06.png|300](/img/user/Assets/Screenshot%202024-03-06%20at%2022.33.06.png)

Control plane - קובע כיצד datagram מנותב בין ראוטרים מקצה לקצה עד הגעה ליעד. כלומר איך הראוטרים מחליטים בינהם לאן הפקטה תלך

![Pasted image 20240306223435.png](/img/user/Assets/Pasted%20image%2020240306223435.png)

לכל ראוטר יהיה רכיב שמהווה את אלגוריתם הניתוב והוא מתממשק עם מישור הבקרה.
## Service model
![Screenshot 2024-03-06 at 22.36.48.png](/img/user/Assets/Screenshot%202024-03-06%20at%2022.36.48.png)
עובד בשיטת best effort כלומר לא מבטיח הגעה של הdatagram ותזמון בסדר ההגעה. 

__פקטה של שכבת הרשת נראת מהצורה:__
![Pasted image 20240307013833.png](/img/user/Assets/Pasted%20image%2020240307013833.png)
## Class Based Addressing in IP
ב [[Computer Science/Networks/IP\|IP]] הזכרנו ש32 הביטים שמרכיבים IP/4 מורכבים ממזהה רשת ומזהה יישות. נשאלת השאלה כיצד מחלקים את הביטים האלה בין מזהה הרשת למזהה היישות בתוך הרשת. אחת הדרכים היא ב CBA.

![Screenshot 2024-03-06 at 22.41.18.png](/img/user/Assets/Screenshot%202024-03-06%20at%2022.41.18.png)

אם ה MSB הוא 0 אז הclass של ה IP הוא A , במצב זה 8 הביטים השמאליים הם מייצגים את מזהה הרשת. אם הביט הוא 1 אז היא שייכת לאחת המחלקות האחרות. במצב שבו השייכות היא ל A יש $2^{7}$ כתובות רשת אפשריות (כי הMSB תפוס)

ככל שעולים ב Class ככה מתווספים עוד 8 ביטים לרשתות אבל גם מאבדים עוד MSB במספר המחלקה.

_היתרון_ של שיטה זאת הוא בכתובת ip אני יכול לקבל במחיר די קטן את החלוקה של הכתובת ל מזהה רשת ויישות.
_החסרון_ של שיטה זאת הוא שמעבר בין מחלקות מקפיץ את כמות הכתובות מעריכית ולכן יש לזה עלות ״כלכלית״ גבוהה.

כפי שאמרנו לכתובת IPv4 יש $2^{32}$ כתובות אפשריות. מרחב הכתובות הזה נוצל מזמן ואומנם יש כבר גרסאות עם יותר כתובות כמו IPv6 אבל זה לא כזה פשוט להמיר את כל הכתובות הקיימות לכתובות מגרסא חדשה. לכן נרצה שיטה פחות בזבזנית מה class addressing כדי להבדיל בין בין מזהה הרשת למזהה היישות.

### Classless Inter-Domain Routing and Subnetting

לכל כתובת IP נצמיד subnet mask שזה כמות הביטים משמאל שמזהים את הרשת. שאר הביטים יזהו את המחשב בתוך הרשת. הפורמט הוא a.b.c.d/x כאשר x הוא הsm.

![Screenshot 2024-03-07 at 0.43.15.png](/img/user/Assets/Screenshot%202024-03-07%20at%200.43.15.png)

השיטה הזו פחות בזבזנית כי היא מאפשרת קפיצות ברמת ביט בודד ולא בית כמו בשיטה המחלקות.  כלומר אומנם אנחנו עדיין מוגבלים ברמת הקפיצות בין כמות המחשבים שאפשר לייצג באותה רשת ברמת הקפיצות בין ביט לביט אבל כעת אלו יותר קטנות.

הsubnet mask הוא בעצם מספר בינארי באורך 32 ביטים שכל ביט אצלו מייצג האם הביט בip שייך למזהה רשת או מזהה היישות (ביט דולק משמעותו שייך למזהה היישות אחרת למזהה הרשת). לאחר מכן נתן לחלץ את המידע מהmask על ידי ביצוע bitwise & .
 
__כתובות IP שמורות__
שומרים בדרך כלל את הכתובת הראשונה עבור הרשת עצמה והכתובת האחרונה היא עבור broadcast של הרשת.

יש גם מספר טווחים שהוקצו ל[private networks](https://en.wikipedia.org/wiki/Private_network) כלומר כתובות של רשתות פנימיות.

![Screenshot 2024-03-07 at 0.54.25.png|200](/img/user/Assets/Screenshot%202024-03-07%20at%200.54.25.png)

יש גם כתובות מיוחדות כמו 127.0.0.1 שאנחנו מכירים כ loopback. 
## Destination-base forwarding
בהינתן פקטה, נרצה לדעת כיצד הראוטר מחליט לאיזה ממשק להעביר את הפקטה כדי שתמשיך להתקדם עד להגיעה ליעד.

לשם כך הראוטר יחזיק בתוכו forwarding table עם שתי עמודות. הראשונה תהיה ה Link Interface והשנייה תהיה Destination Address Range שתכיל בתוכו את טווח הכתובות ה IP שמיועדות לעבור לממשק שבעמודה הראשונה. נזכיר שפקטה של שכבת הרשת מכילה כתובת IP של הsource וכתובת IP של הdestination ב תחיליות שלה.

![Screenshot 2024-03-07 at 1.40.48.png](/img/user/Assets/Screenshot%202024-03-07%20at%201.40.48.png)
נשים לב שייצוג של טווח בטבלה הוא על ידי סימון ב * את הביטים שברצוננו לאפשר להיות להיות במצב ״חופשי״ כלומר גם כבויים וגם דלוקים. טווח בשורה מסוימת יכול להיות ״ספציפי״ יותר מאחר או להכיל טווח בשורה אחרת. כאשר הראוטר רוצה לקבוע לאן פקטה צריכה ללכת הוא מחפש את האחד שטווח הכתובות המכיל אותו הוא הקטן ביותר (יכול להיות כמה אבל בהכרח יהיה טווח קטן יותר מהשני)

נסתכל על ה ip הבא $\text{11001000  00010111  00010110  10100001}$ .

בעצם מחפשים את הprefix הארוך ביותר שמתאים לשורה כלשהי בטבלה. אם נסתכל על הכתובת הדוגמה, נראה שעבור שלושת השורות, הבית הראשון מתאים וגם הבית השני. לעומת זאת, הבית השלישי מתאים רק לשורה הראשונה בטבלה כי הוא היחיד שהבית ה5 משמאל הוא 0 ולכן השורה הראשונה מכילה את הprefix הארוך ביותר.

![Pasted image 20240307112934.png](/img/user/Assets/Pasted%20image%2020240307112934.png)
באמצעות הטבלה הזאת ספקי אינטרנט יכולים להשתמש בראוטרים שלהם כדי להעביר מידע לפי הארגונים שנמצאים תחתם ברשת. הקונספט הזה נקרא hierarchical addressing והוא בעצם מאפשר להקצות עוד ביטים למזהה רשת דרך ה mask ואלו יהוו מזהים לארגונים.

![Screenshot 2024-03-07 at 11.30.53.png](/img/user/Assets/Screenshot%202024-03-07%20at%2011.30.53.png)

״האינטרנט״ בתמונה למעלה מהווה ראוטרים אחרים שמקבלים מידע מספקי אינטרנט על טווחי הכתובות שהם מעוניינים שאותם ראוטרים יעבירו אליהם את המידע. לפי הממשק שממנו באה הבקשה הראוטרים יודעים לבנות את הforward table שלהם.
## IP Datagram Format
![Screenshot 2024-03-07 at 1.50.33.png](/img/user/Assets/Screenshot%202024-03-07%20at%201.50.33.png)
נשים לב שבשכבה זאת נשמר ה offset של הפרגמנטצייה שפרוטוקול TCP מנסה להמנע ממנו. 
פרמטר חשוב נוסף הוא ttl שזה נועד למנוע מצב של תנודה אינסופית של פקטה בין הראוטרים.

### IP Calculations
#### שאלה 1
![Screenshot 2024-03-07 at 15.11.42.png](/img/user/Assets/Screenshot%202024-03-07%20at%2015.11.42.png)
מכיוון שלא ניתן subnet mask אזי מדובר בשיטה המבוססת מחלקות. 
$$138_{10} \equiv \textcolor{red}{10}001010_{2}$$
הביט השמאלי הוא 1 ומימינו מכובה ולכן הכתובת שייכת למחלקה B. לכן המזהה רשת הוא 138.64 .

#### שאלה 2
![Screenshot 2024-03-07 at 15.18.59.png](/img/user/Assets/Screenshot%202024-03-07%20at%2015.18.59.png)
ה subnet mask הוא 23 (כמות הביטים הדלוקים היא 23 מתוך 32). נבצע & בין כתובת ה IP ל subnet mask בבינארית ונקבל  
![Screenshot 2024-03-07 at 15.25.18.png](/img/user/Assets/Screenshot%202024-03-07%20at%2015.25.18.png)

#### שאלה 3
![Screenshot 2024-03-07 at 15.26.34.png](/img/user/Assets/Screenshot%202024-03-07%20at%2015.26.34.png)
ראשית נזהה כמה כתובות יש ברשת הזאת לכל היותר
מכיוון שה subnet mask הוא 26 יש 6 ביטים שמייצגים מחשבים בתוך הרשת ולכן יש $2^{6}=64$ כתובות אפשריות ברשת. נשים לב שמפרישים שתי כתובות לשימושים מיוחדים (הראשונה והאחרונה) ולכן יש 62 כתובות אפשריות. לכן במקרה שלנו כל כתובת בטווח
101.101.101.65 - 101.101.101.126 מתאימה לנו.

#### שאלה 4
![Pasted image 20240307225919.png](/img/user/Assets/Pasted%20image%2020240307225919.png)
ברשת שלנו יש 64 כתובות אפשריות. נשים לב, שהספק מעוניין לדעת לכל כתובת לאיזה לקוח היא שייכת. מכיוון שיש 4 לקוחות, הספק מקריב את 2 הביטים הכי שמאליים __מהחלק של הכתובת ולא מהחלק של מזהה הרשת__, בכדי לזהות את הלקוח. הסיבה ל 2 ביטים היא שאפשר בעזרתם לייצג 4 לקוחות. בלוקי הכתובות ייראו מהצורה

1. 101.101.101.64/28
2. 101.101.101.80/28
3. 101.101.101.96/28
4. 101.101.101.101.112/28

נשים לב, שכאשר ספק האינטרנט מפרסם לעולם את הכתובות שהוא מעוניין שישלחו אליו, הוא מפרסם רק את הכתובת הראשונה. כאשר חבילה המיועדת לכתובת ip כלשהי בטווח הזה תגיע לראוטר של ספק האינטרנט, הראוטר יסתכל על 2 הביטים הבאים ולפי זה ידע לאיזה לקוח יש להעביר את החבילה. התהליך שבו ״איחדנו״ מספר תתי רשתות תחת רשת אחת נקרא [route aggregation](https://sc1.checkpoint.com/documents/R80.40/WebAdminGuides/EN/CP_R80.40_Gaia_Advanced_Routing_AdminGuide/Topics-GARG/Route-Aggregation.htm).

#### שאלה 5
![Screenshot 2024-03-07 at 23.07.12.png](/img/user/Assets/Screenshot%202024-03-07%20at%2023.07.12.png)

בשלב הראשון ספק האינטרנט יעביר שכל הפקטות עם הdst ip כפי שמצויין בתמונה, יש להעביר את הכתובות האלה אליו.

![Screenshot 2024-03-07 at 23.09.04.png|200](/img/user/Assets/Screenshot%202024-03-07%20at%2023.09.04.png)

נשים לב שזה ממשק אחד מבין ה4 כי הנתב חייב להתחבר לאינטרנט. נשארנו עם 3 ממשקים.

אם כן נוכל להקדיש 2 ביטים עבור ניתוב לכל אחד מ3 הממשקים כאשר הממשק השלישי (עם ביט שמאלי מבין ה2 שערכו יהיה 1) יקבל פי 2 יותר כתובות פנימיות, את החצי השני של מרחב הכתובות הפנימיות.

![Screenshot 2024-03-07 at 23.13.40.png](/img/user/Assets/Screenshot%202024-03-07%20at%2023.13.40.png)

כעת נתחיל להתאים לקוחות לנתבים:
![Screenshot 2024-03-07 at 23.23.10.png|200](/img/user/Assets/Screenshot%202024-03-07%20at%2023.23.10.png)

בגלל שיש לנו לקוחות שרוצים פחות מ 100 כתובות נוכל להשתמש בנתב האמצעי (התכלת) ולחבר אותו לנתב נוסף שיהיו לו 3 ממשקים פנויים ולכל אחד מהממשקים נצמיד לקוח

![Screenshot 2024-03-07 at 23.24.45.png|250](/img/user/Assets/Screenshot%202024-03-07%20at%2023.24.45.png)

באותו אופן גם לראוטר עם 2048 כתובות
![Screenshot 2024-03-07 at 23.26.05.png|250](/img/user/Assets/Screenshot%202024-03-07%20at%2023.26.05.png)

__וסה״כ__
![Screenshot 2024-03-07 at 23.28.15.png](/img/user/Assets/Screenshot%202024-03-07%20at%2023.28.15.png)

![Pasted image 20240307235147.png](/img/user/Assets/Pasted%20image%2020240307235147.png)
נשים לב שמכיוון שכל כתובת היא מבוססת בינארית צריך לבדוק כמה ביטים צריך עבור לפחות 50 כתובות.
* במקרה שלנו מדובר ב $2^{6}=64$ כתובות כלומר ב 6 ביטים.
* לא ניתן פחות, כי הקפיצות הן בינאריות
* לכן, נוכל לחלק את הכתובות ל 4 תתי רשתות.

## ICMP 
פרוטוקול של שכבת הרשת שמאפשר להעביר errors, pings ו network diagnostics. הודעות ICMP נבנות בשכבת ה־IP, בדרך כלל מחבילת IP רגילה, אשר יצרה תגובת ICMP.‏ IP עוטף את הודעת ה ICMP המתאימה בכותרת IP חדשה, כדי לשולחה חזרה למכונה ששלחה את ההודעה המקורית, ולהעביר את החבילה הנוצרת באופן הרגיל.

### Traceroute 
באמצעות הפקודה הזאת ניתן לאתר את הנתבים שהמידע עובר בהם כדי להגיע ליעד.

![Screenshot 2024-03-08 at 0.00.38.png](/img/user/Assets/Screenshot%202024-03-08%20at%200.00.38.png)

הרעיון הוא כל פעם לשלוח פקטת UDP עם ttl שערכו הוא i כאשר i מייצג את מספר הפקטה ששלחנו. 

הפקטה הראשונה תקבל ttl=1 השנייה ttl=2 וכן הלאה. ttl הוא פרמטר שמתעדכן בכל פעם שהפקטה מגיעה לראוטר. הראוטר מוריד ערך זה ב 1 , אם הערך הוא 0 הוא זורק את הפקטה ומחזיר הודעת שגיאה עם פרוטוקול ICMP. לכן עבור הפקטה הi הראוטר ה i יחזיר שגיאה מסוג 11 עם קוד 0 (ttl expired)

![Screenshot 2024-03-08 at 0.04.12.png|350](/img/user/Assets/Screenshot%202024-03-08%20at%200.04.12.png)
הודעות השגיאה הללו מכילות את שם הראוטר וה ip שלו. 
תנאי העצירה הוא הגעה ליעל אבל בגלל שאין port מוגדר שוב יוחזר שגיאת ICMP מסוג port unreachable (type 3, code 3) והפקודה תפסיק לרוץ.

__בטרמינל של windows :__
![Pasted image 20240308000713.png](/img/user/Assets/Pasted%20image%2020240308000713.png)

__בטרמינל של לינוקס :__
![Pasted image 20240308000859.png](/img/user/Assets/Pasted%20image%2020240308000859.png)
נשים לב שהפקודה גם שומרת את ה RTT. 
כמו כן, בלינוקס השגיאה מחזירה גם את מספר הלינק שממנו הגענו (לכן גם בתמונה לכל ראוטר יש 2 כתובות לפי הלינק).