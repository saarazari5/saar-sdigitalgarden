---
{"dateCreated":"2024-02-27 13:01","tags":["networks"],"pageDirection":"rtl","dg-publish":true,"permalink":"/computer-science/networks/network-layer/","dgPassFrontmatter":true}
---

# שכבת הרשת
תפקיד שכבת הרשת הוא לשנע segment מהרכיב השולח לרכיב המקבל.  

__השולח__ - מייצר datagram מה segment ומעביר ל link layer. 
__המקבל__ - מעביר את הsegment ל[[Computer Science/Networks/Transport Layer\|Transport Layer]] .

התפקיד של שכבת הרשת הוא לא בידיוק להעביר למחשב המקבל אלא לרשת שבה נמצא המחשב המקבל , [[Link Layer\|Link Layer]] אחרי להעביר את המידע למחשב המתאים ברשת המקומית.

ל[[Computer Science/Networks/Network Devices\|ראוטר]] יש תפקיד מרכזי בשכבה זו:
	* הוא בודק את כל שדות ה headers בכל ה IP datagrams.
	* משנע datagrams מ input ports ל output ports כדי שיוכל להעביר אותם את כל הדרך עד לרשת המתאימה
	![Screenshot 2024-03-06 at 20.07.49.png](/img/user/Assets/Screenshot%202024-03-06%20at%2020.07.49.png)
ישנן שתי פונקציות עיקריות של שכבת הרשת
forwarding- שינוע פקטות מראוטר אחד לראוטר הבא בתור.
routing - קביעת המסלול מהשולח ליעד.

![Screenshot 2024-03-06 at 22.30.51.png|350](/img/user/Assets/Screenshot%202024-03-06%20at%2022.30.51.png)

על שכבת הרשת נסתכל בשני מישורים עיקריים
Data plane - כאשר הראוטר מקבל חבילה הוא קובע כיצד ה datagram המתקבל מinput כלשהו יעבור ל output port של הראוטר הבא.

![Screenshot 2024-03-06 at 22.33.06.png|300](/img/user/Assets/Screenshot%202024-03-06%20at%2022.33.06.png)

Control plane - קובע כיצד datagram מנותב בין ראוטרים מקצה לקצה עד הגעה ליעד. כלומר איך הראוטרים מחליטים בינהם לאן הפקטה תלך

![Pasted image 20240306223435.png](/img/user/Assets/Pasted%20image%2020240306223435.png)

לכל ראוטר יהיה רכיב שמהווה את אלגוריתם הניתוב והוא מתממשק עם מישור הבקרה.

__Service model של שכבת הרשת:__
![Screenshot 2024-03-06 at 22.36.48.png](/img/user/Assets/Screenshot%202024-03-06%20at%2022.36.48.png)
עובד בשיטת best effort כלומר לא מבטיח הגעה של הdatagram ותזמון בסדר ההגעה. 

__פקטה של שכבת הרשת נראת מהצורה:__
![Pasted image 20240307013833.png](/img/user/Assets/Pasted%20image%2020240307013833.png)
## IP
כתובת IP מהווה אמצעי זיהוי של כל שרת באינטרנט ושל כל ציוד קצה שמחובר לאינטרנט.
כתובת IP היא ייחודית ומוקצית בד״כ באופן אוטומי. בכל בקשה שנשלח לשרת, כתובת ה IP מוצמדת לכל בקשה שתשלח כדי שהשרת ידע לאן להחזיר תשובה. באופן דומה הדפדפן במחשב זקוק לכתובת ה IP של השרת כדי לדעת לאן לשלוח את הבקשה.

### מבנה כתובת ה IP
כל כתובת IP , מורכבת מרצף של ארבעה מספרים ובינהם נקודות. כל מספר נמצא בטווח $[0,255]$, לדוגמה $183.79.248.252$ . עבור כל מספר בכתובת קיימות $256$ אפשרויות לכן לפי [[Computer Science/Discrete Math/combinatorics basics\|עקרונות קומבינטוריקה בסיסיים]] נבין שיש בסה״כ $2^{32}$ כתובות ip. כיוון שכיום המספר הזה לא גדול במיוחד ישנו מבנה חדש של הכתובת שמאפשר לייצג $2^{128}$ כתובות. למבנה הזה קוראים IPv6 לעומת IPv4 שזאת הגרסה הנ״ל. כיום משתמשים בשני הגרסאות.

![Screenshot 2024-01-18 at 20.10.48.png](/img/user/Assets/Screenshot%202024-01-18%20at%2020.10.48.png)

>[!info] איתור כתובת גיאוגרפית באמצעות כתובת IP
>אנשים רגילים לא יכולים לדעת איפה אנחנו גרים על סמך כתובת הIP שלנו, אך בחוזה ההתקשרות שאנו חתומים עם ספק האינטרנט, רשומה כתובת הבית שלנו וזאת מקושרת לכתובת ה IP של המחשב שלנו.

>[!info] הפקודה PING
> `ping IP` היא פקודה שמאפשרת לנו לבדוק אם שני מחשבים מקושרים זה לזה. הפקודה שולחת הודעות אל כתובת ה IP של היעד שאנחנו בוחרים. אם ההודעות מגיעות ליעד ואם היעד מוכן לענות לנו, נקבל על כל הודעה תשובה ובה משך הזמן שלקח להודעה לעבור בין שני המחשבים. 
>
![Screenshot 2024-01-18 at 22.01.07.png](/img/user/Assets/Screenshot%202024-01-18%20at%2022.01.07.png) 
נשים לב שהפרוטוקול שping משתמש בו הוא [ICMP](https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol) שזה פרוטוקול שמיועד לשליחת הודעות שגיאה או metadata כאשר מעבירים מידע

### מזהה רשת, מזהה יישות
בכתובות IP מסתתר מידע נוסף שחשוב לפעילות של [[Computer Science/Networks/Computer Networks Intro and Protocol layers#Network Layer\|שכבת הרשת]]. 
כל כתובת IP מכילה את המידע הבא:
א) __מזהה רשת- Network ID:__ לאיזו תת רשת שייכת כתובת ה IP?
ב) __מזהה ישות - Entity ID:__ לאיזה כרטיס רשת, חומרת המחשב המאפשרת למכשיר להתחבר לרשת מחשבים או לרשת האינטרנט (NIC- Network Interface Controller) שייכת הכתובת?

![Screenshot 2024-01-18 at 22.06.31.png|300](/img/user/Assets/Screenshot%202024-01-18%20at%2022.06.31.png)

## Class Based Addressing in IP
ב [[Computer Science/Networks/IP\|IP]] הזכרנו ש32 הביטים שמרכיבים IP/4 מורכבים ממזהה רשת ומזהה יישות. נשאלת השאלה כיצד מחלקים את הביטים האלה בין מזהה הרשת למזהה היישות בתוך הרשת. אחת הדרכים היא ב CBA.

![Screenshot 2024-03-06 at 22.41.18.png](/img/user/Assets/Screenshot%202024-03-06%20at%2022.41.18.png)

אם ה MSB הוא 0 אז הclass של ה IP הוא A , במצב זה 8 הביטים השמאליים הם מייצגים את מזהה הרשת. אם הביט הוא 1 אז היא שייכת לאחת המחלקות האחרות. במצב שבו השייכות היא ל A יש $2^{7}$ כתובות רשת אפשריות (כי הMSB תפוס)

ככל שעולים ב Class ככה מתווספים עוד 8 ביטים לרשתות אבל גם מאבדים עוד MSB במספר המחלקה.

_היתרון_ של שיטה זאת הוא בכתובת ip אני יכול לקבל במחיר די קטן את החלוקה של הכתובת ל מזהה רשת ויישות.
_החסרון_ של שיטה זאת הוא שמעבר בין מחלקות מקפיץ את כמות הכתובות מעריכית ולכן יש לזה עלות ״כלכלית״ גבוהה.

כפי שאמרנו לכתובת IPv4 יש $2^{32}$ כתובות אפשריות. מרחב הכתובות הזה נוצל מזמן ואומנם יש כבר גרסאות עם יותר כתובות כמו IPv6 אבל זה לא כזה פשוט להמיר את כל הכתובות הקיימות לכתובות מגרסא חדשה. לכן נרצה שיטה פחות בזבזנית מה class addressing כדי להבדיל בין בין מזהה הרשת למזהה היישות.

### Classless Inter-Domain Routing and Subnetting
לכל כתובת IP נצמיד subnet mask שזה כמות הביטים משמאל שמזהים את הרשת. שאר הביטים יזהו את המחשב בתוך הרשת. הפורמט הוא a.b.c.d/x כאשר x הוא הsm.

![Screenshot 2024-03-07 at 0.43.15.png](/img/user/Assets/Screenshot%202024-03-07%20at%200.43.15.png)

השיטה הזו פחות בזבזנית כי היא מאפשרת קפיצות ברמת ביט בודד ולא בית כמו בשיטה המחלקות.  כלומר אומנם אנחנו עדיין מוגבלים ברמת הקפיצות בין כמות המחשבים שאפשר לייצג באותה רשת ברמת הקפיצות בין ביט לביט אבל כעת אלו יותר קטנות.

הsubnet mask הוא בעצם מספר בינארי באורך 32 ביטים שכל ביט אצלו מייצג האם הביט בip שייך למזהה רשת או מזהה היישות (ביט דולק משמעותו שייך למזהה היישות אחרת למזהה הרשת). לאחר מכן נתן לחלץ את המידע מהmask על ידי ביצוע bitwise & .
 
__כתובות IP שמורות__
שומרים בדרך כלל את הכתובת הראשונה עבור הרשת עצמה והכתובת האחרונה היא עבור broadcast של הרשת.

יש גם מספר טווחים שהוקצו ל[private networks](https://en.wikipedia.org/wiki/Private_network) כלומר כתובות של רשתות פנימיות.

![Screenshot 2024-03-07 at 0.54.25.png|200](/img/user/Assets/Screenshot%202024-03-07%20at%200.54.25.png)

יש גם כתובות מיוחדות כמו 127.0.0.1 שאנחנו מכירים כ loopback. 
## Destination-base forwarding
בהינתן פקטה, נרצה לדעת כיצד הראוטר מחליט לאיזה ממשק להעביר את הפקטה כדי שתמשיך להתקדם עד להגיעה ליעד.

לשם כך הראוטר יחזיק בתוכו forwarding table עם שתי עמודות. הראשונה תהיה ה Link Interface והשנייה תהיה Destination Address Range שתכיל בתוכו את טווח הכתובות ה IP שמיועדות לעבור לממשק שבעמודה הראשונה. נזכיר שפקטה של שכבת הרשת מכילה כתובת IP של הsource וכתובת IP של הdestination ב תחיליות שלה.

![Screenshot 2024-03-07 at 1.40.48.png](/img/user/Assets/Screenshot%202024-03-07%20at%201.40.48.png)
נשים לב שייצוג של טווח בטבלה הוא על ידי סימון ב * את הביטים שברצוננו לאפשר להיות להיות במצב ״חופשי״ כלומר גם כבויים וגם דלוקים. טווח בשורה מסוימת יכול להיות ״ספציפי״ יותר מאחר או להכיל טווח בשורה אחרת. כאשר הראוטר רוצה לקבוע לאן פקטה צריכה ללכת הוא מחפש את האחד שטווח הכתובות המכיל אותו הוא הקטן ביותר (יכול להיות כמה אבל בהכרח יהיה טווח קטן יותר מהשני)

נסתכל על ה ip הבא $\text{11001000  00010111  00010110  10100001}$ .

בעצם מחפשים את הprefix הארוך ביותר שמתאים לשורה כלשהי בטבלה. אם נסתכל על הכתובת הדוגמה, נראה שעבור שלושת השורות, הבית הראשון מתאים וגם הבית השני. לעומת זאת, הבית השלישי מתאים רק לשורה הראשונה בטבלה כי הוא היחיד שהבית ה5 משמאל הוא 0 ולכן השורה הראשונה מכילה את הprefix הארוך ביותר.

![Pasted image 20240307112934.png](/img/user/Assets/Pasted%20image%2020240307112934.png)
באמצעות הטבלה הזאת ספקי אינטרנט יכולים להשתמש בראוטרים שלהם כדי להעביר מידע לפי הארגונים שנמצאים תחתם ברשת. הקונספט הזה נקרא hierarchical addressing והוא בעצם מאפשר להקצות עוד ביטים למזהה רשת דרך ה mask ואלו יהוו מזהים לארגונים.

![Screenshot 2024-03-07 at 11.30.53.png](/img/user/Assets/Screenshot%202024-03-07%20at%2011.30.53.png)

״האינטרנט״ בתמונה למעלה מהווה ראוטרים אחרים שמקבלים מידע מספקי אינטרנט על טווחי הכתובות שהם מעוניינים שאותם ראוטרים יעבירו אליהם את המידע. לפי הממשק שממנו באה הבקשה הראוטרים יודעים לבנות את הforward table שלהם.
## IP Datagram Format
![Screenshot 2024-03-07 at 1.50.33.png](/img/user/Assets/Screenshot%202024-03-07%20at%201.50.33.png)
נשים לב שבשכבה זאת נשמר ה offset של הפרגמנטצייה שפרוטוקול TCP מנסה להמנע ממנו. 
פרמטר חשוב נוסף הוא ttl שזה נועד למנוע מצב של תנודה אינסופית של פקטה בין הראוטרים.

### IP Calculations
#### שאלה 1
![Screenshot 2024-03-07 at 15.11.42.png](/img/user/Assets/Screenshot%202024-03-07%20at%2015.11.42.png)
מכיוון שלא ניתן subnet mask אזי מדובר בשיטה המבוססת מחלקות. 
$$138_{10} \equiv \textcolor{red}{10}001010_{2}$$
הביט השמאלי הוא 1 ומימינו מכובה ולכן הכתובת שייכת למחלקה B. לכן המזהה רשת הוא 138.64 .

#### שאלה 2
![Screenshot 2024-03-07 at 15.18.59.png](/img/user/Assets/Screenshot%202024-03-07%20at%2015.18.59.png)
ה subnet mask הוא 23 (כמות הביטים הדלוקים היא 23 מתוך 32). נבצע & בין כתובת ה IP ל subnet mask בבינארית ונקבל  
![Screenshot 2024-03-07 at 15.25.18.png](/img/user/Assets/Screenshot%202024-03-07%20at%2015.25.18.png)

#### שאלה 3
![Screenshot 2024-03-07 at 15.26.34.png](/img/user/Assets/Screenshot%202024-03-07%20at%2015.26.34.png)
ראשית נזהה כמה כתובות יש ברשת הזאת לכל היותר
מכיוון שה subnet mask הוא 26 יש 6 ביטים שמייצגים מחשבים בתוך הרשת ולכן יש $2^{6}=64$ כתובות אפשריות ברשת. נשים לב שמפרישים שתי כתובות לשימושים מיוחדים (הראשונה והאחרונה) ולכן יש 62 כתובות אפשריות. לכן במקרה שלנו כל כתובת בטווח
101.101.101.65 - 101.101.101.126 מתאימה לנו.

#### שאלה 4
![Pasted image 20240307225919.png](/img/user/Assets/Pasted%20image%2020240307225919.png)
ברשת שלנו יש 64 כתובות אפשריות. נשים לב, שהספק מעוניין לדעת לכל כתובת לאיזה לקוח היא שייכת. מכיוון שיש 4 לקוחות, הספק מקריב את 2 הביטים הכי שמאליים __מהחלק של הכתובת ולא מהחלק של מזהה הרשת__, בכדי לזהות את הלקוח. הסיבה ל 2 ביטים היא שאפשר בעזרתם לייצג 4 לקוחות. בלוקי הכתובות ייראו מהצורה

1. 101.101.101.64/28
2. 101.101.101.80/28
3. 101.101.101.96/28
4. 101.101.101.101.112/28

נשים לב, שכאשר ספק האינטרנט מפרסם לעולם את הכתובות שהוא מעוניין שישלחו אליו, הוא מפרסם רק את הכתובת הראשונה. כאשר חבילה המיועדת לכתובת ip כלשהי בטווח הזה תגיע לראוטר של ספק האינטרנט, הראוטר יסתכל על 2 הביטים הבאים ולפי זה ידע לאיזה לקוח יש להעביר את החבילה. התהליך שבו ״איחדנו״ מספר תתי רשתות תחת רשת אחת נקרא [route aggregation](https://sc1.checkpoint.com/documents/R80.40/WebAdminGuides/EN/CP_R80.40_Gaia_Advanced_Routing_AdminGuide/Topics-GARG/Route-Aggregation.htm).

#### שאלה 5
![Screenshot 2024-03-07 at 23.07.12.png](/img/user/Assets/Screenshot%202024-03-07%20at%2023.07.12.png)

בשלב הראשון ספק האינטרנט יעביר שכל הפקטות עם הdst ip כפי שמצויין בתמונה, יש להעביר את הכתובות האלה אליו.

![Screenshot 2024-03-07 at 23.09.04.png|200](/img/user/Assets/Screenshot%202024-03-07%20at%2023.09.04.png)

נשים לב שזה ממשק אחד מבין ה4 כי הנתב חייב להתחבר לאינטרנט. נשארנו עם 3 ממשקים.

אם כן נוכל להקדיש 2 ביטים עבור ניתוב לכל אחד מ3 הממשקים כאשר הממשק השלישי (עם ביט שמאלי מבין ה2 שערכו יהיה 1) יקבל פי 2 יותר כתובות פנימיות, את החצי השני של מרחב הכתובות הפנימיות.

![Screenshot 2024-03-07 at 23.13.40.png](/img/user/Assets/Screenshot%202024-03-07%20at%2023.13.40.png)

כעת נתחיל להתאים לקוחות לנתבים:
![Screenshot 2024-03-07 at 23.23.10.png|200](/img/user/Assets/Screenshot%202024-03-07%20at%2023.23.10.png)

בגלל שיש לנו לקוחות שרוצים פחות מ 100 כתובות נוכל להשתמש בנתב האמצעי (התכלת) ולחבר אותו לנתב נוסף שיהיו לו 3 ממשקים פנויים ולכל אחד מהממשקים נצמיד לקוח

![Screenshot 2024-03-07 at 23.24.45.png|250](/img/user/Assets/Screenshot%202024-03-07%20at%2023.24.45.png)

באותו אופן גם לראוטר עם 2048 כתובות
![Screenshot 2024-03-07 at 23.26.05.png|250](/img/user/Assets/Screenshot%202024-03-07%20at%2023.26.05.png)

__וסה״כ__
![Screenshot 2024-03-07 at 23.28.15.png](/img/user/Assets/Screenshot%202024-03-07%20at%2023.28.15.png)

![Pasted image 20240307235147.png](/img/user/Assets/Pasted%20image%2020240307235147.png)
נשים לב שמכיוון שכל כתובת היא מבוססת בינארית צריך לבדוק כמה ביטים צריך עבור לפחות 50 כתובות.
* במקרה שלנו מדובר ב $2^{6}=64$ כתובות כלומר ב 6 ביטים.
* לא ניתן פחות, כי הקפיצות הן בינאריות
* לכן, נוכל לחלק את הכתובות ל 4 תתי רשתות.

## ICMP 
פרוטוקול של שכבת הרשת שמאפשר להעביר errors, pings ו network diagnostics. הודעות ICMP נבנות בשכבת ה־IP, בדרך כלל מחבילת IP רגילה, אשר יצרה תגובת ICMP.‏ IP עוטף את הודעת ה ICMP המתאימה בכותרת IP חדשה, כדי לשולחה חזרה למכונה ששלחה את ההודעה המקורית, ולהעביר את החבילה הנוצרת באופן הרגיל.

### Traceroute 
באמצעות הפקודה הזאת ניתן לאתר את הנתבים שהמידע עובר בהם כדי להגיע ליעד.

![Screenshot 2024-03-08 at 0.00.38.png](/img/user/Assets/Screenshot%202024-03-08%20at%200.00.38.png)

הרעיון הוא כל פעם לשלוח פקטת UDP עם ttl שערכו הוא i כאשר i מייצג את מספר הפקטה ששלחנו. 

הפקטה הראשונה תקבל ttl=1 השנייה ttl=2 וכן הלאה. ttl הוא פרמטר שמתעדכן בכל פעם שהפקטה מגיעה לראוטר. הראוטר מוריד ערך זה ב 1 , אם הערך הוא 0 הוא זורק את הפקטה ומחזיר הודעת שגיאה עם פרוטוקול ICMP. לכן עבור הפקטה הi הראוטר ה i יחזיר שגיאה מסוג 11 עם קוד 0 (ttl expired)

![Screenshot 2024-03-08 at 0.04.12.png|350](/img/user/Assets/Screenshot%202024-03-08%20at%200.04.12.png)
הודעות השגיאה הללו מכילות את שם הראוטר וה ip שלו. 
תנאי העצירה הוא הגעה ליעל אבל בגלל שאין port מוגדר שוב יוחזר שגיאת ICMP מסוג port unreachable (type 3, code 3) והפקודה תפסיק לרוץ.

__בטרמינל של windows :__
![Pasted image 20240308000713.png](/img/user/Assets/Pasted%20image%2020240308000713.png)

__בטרמינל של לינוקס :__
![Pasted image 20240308000859.png](/img/user/Assets/Pasted%20image%2020240308000859.png)
נשים לב שהפקודה גם שומרת את ה RTT. 
כמו כן, בלינוקס השגיאה מחזירה גם את מספר הלינק שממנו הגענו (לכן גם בתמונה לכל ראוטר יש 2 כתובות לפי הלינק).

## NAT 
network address translation - בפועל יש הרבה יותר מחשבים מכתובות ipv4 וגם הטכנולוגייה לא תומכת בהעברה מידית ומלאה ל ipv6. לשם כך, משתמשים ב NAT, טכניקת ניתוב שמאפשרת למספר מכשירים ברשת מקומית לחלוק רק כתובת IP אחת ברחבי האינטרנט. 

![Screenshot 2024-04-06 at 14.10.02.png](/img/user/Assets/Screenshot%202024-04-06%20at%2014.10.02.png)

* דיברנו על כך ש [[Computer Science/Networks/Application Layer#DHCP\|DHCP]] הוא פרוטוקול שמספק כתובת IP לhost שמתחבר לרשת פעם ראשונה. חשוב להבחין שפרוטוקול זה מספק את כתובות הרשת הפנימיות (מצד ימין בתמונה) בעוד שבאינטרנט הכתובת של כל הרשת הזאת הוא הכתובת 138.76.29.7 (וזה החלק ששכבת הרשת ביחד עם NAT אחראית עליו). 

* כאשר datagram עוזבים את הlocal network , כתובת ה ip שנמצאת ב header היא הכתובת 138.76.29.7. אבל כאשר הdatagram נשארות ברשת המקומית הכתובות ip שלהם ב header רשומות לפי הכתובת הפנימית שלהם.

__איך תהליך התרגום עובד?__
1) נניח שאפליקצייה במחשב עם source ip של 10.0.0.1 רצה על port של 3345 ורוצה לשלות datagram לכתובת 128.119.40.186 על גבי פורט 80.
2) בheaders של שכבת הרשת רשום ב source ו destination את הכתובות הנ״ל.
3) באמצעות subnet mask (השוואת 24 הביטים של הכתובת שלו עם הכתובת של היעד) המחשב הגיע למסקנה שהרשת destination היא לא ברשת המקומית ולכן הוא מעביר את הבקשה לdefault gateway, הוא מגלה את הMAC של ה default gateway עם [[Computer Science/Networks/ARP-Address Resolution Protocol\|ARP]] ומעביר את הבקשה לראוטר בכתובת 10.0.0.4.
4) הראוטר, שכבר יודע דרך איזה ממשק להוציא את החבילה באמצעות forward table הולך ל NAT translation table, וממפה בין הכתובת ip והפורט הפנימיים של הרשת המקומית וממפה את זה לכתובת הip הגלובלית שהרשת מכירה ולport שבה הראוטר עצמו מאזין לבקשה. נניח שהכתובת היא 138.76.29.7 על פורט 5001, משנה את הheader ושולחת את הבקשה.
5) כאשר מתקבלת תשובה עבור הבקשה זו הראוטר חוזר לטבלה רואה מי הכתובת המקומית שצריכה לקבל את הבקשה ומעביר אליה.

__התהליך הזה שקוף לחלוטין לאפליקציה במחשב ששלח את הבקשה__ 

![Screenshot 2024-04-06 at 14.43.58.png](/img/user/Assets/Screenshot%202024-04-06%20at%2014.43.58.png)

>[!note] בעיתיות ה NAT
NAT הוא לא פרוטוקול של שכבת הרשת! הוא מעין hack שמאפשר לפתור את הבעיה של מחסור כתובת מסוג IPv4 (שאמורה להפתר עם מעבר ל IPv6 אבל הטכנולוגיה לא מאפשרת מעבר שכזה) ולכן שיטה זאת קצת שנויה במחלוקת שכן היא משנה headers של שכבת הרשת ונותנת לראוטר אחריות נוספת. כמו כן בגלל ההכמסה של NAT נפגעת היכולת לעשות חיבור ישיר (end to end) בין מחשב אחד לאחר ברשת החיצונית כמו בTCP , על ה NAT router לפתור בעיות אלו בעצמו מה שגם מערבב בין השכבות. 
### NAT Variations
כפי שניתן לראות ב [RFC 38489](https://datatracker.ietf.org/doc/html/rfc3489) ישנם מספר סוגים של NAT routers:

_(מסמכי בקשה להערות הם סדרה של מזכרים בתחום טכנולוגיות אינטרנט שונות. לרוב, המזכרים מתארים מחקר חדש, חדשנות טכנולוגית או מתודולוגיה המרחיבים באופן כלשהו את טכנולוגיות האינטרנט הקיימות)._ 

1) Full Cone - המיפוי הוא קבוע, כל בקשה שתשלח מהip והפורט הפנימיים ימופו לאותו כתובת ip ו פורט חיצוניים. כמו כן כל מחשב אחר ששולח פקטה ל ip והפורט החיצוני שממופים לכתובת פנימיות יגיעו לכתובות האלו (גם אם המחשב ברשת הפנימית לא שלח בקשה).
2) Restricted Cone -  כמו ה Full, המיפוי קבוע אבל מחשב חיצוני עם כתובת X כלשהי יכול לשלוח פקטה למחשב פנימי רק אם המחשב הפנימי שלח בעבר פקטה למחשב החיצוני בכתובת X. כלומר מניחים שהמחשבים שנמצאים תחת NAT הם מחשבי Clients שלא אמורים לקבל פקטות בלי לבקש זאת מראש. נשים לב שההגבלה היא רק על כתובת IP ולא פורט.
3) Port Restricted -  כמו Restricted רק שההגבלה ספציפית יותר גם למספרי פורט. כלומר רק אם המחשב הפנימי שלח בקשה לכתובת X בפורט P אז כתובת זאת והפורט הזה יכולים לשלוח בחזרה פקטות. ישנה בעיה שעולה מידית, מה קורה כששני מחשבים נמצאים מאחורי NAT מסוג Port Restricted , איך הם יתקשרו אחד עם השני? שכן, הפורטים שאנחנו נשלח אליהם יהיו שונים בגלל המיפוי.
4) j - כל הבקשות מאותו ip ו פורט פנימיים ליעד כלשהו ימופו לאותו ip ופורט חיצוניים. אם המחשב הפנימי ישלח לכתובת אחרת המיפוי יהיה אחר. כמו כן, רק מחשבים חיצוניים שקיבלו פקטה יכולים לשלוח פקטת [[Computer Science/Networks/Transport Layer\|UDP]] בחזרה ל internal host.

(לא אעמיק כאן בחשיבות של זה, אבל בגדול זה קשור לנושאים כמו firewall ואבטחה, איך אפשר לדעת שחבילת UDP נשלחת במסגרת חיבור שבוצע בעבר).  

### Architectures
השיטות NAT הנ״ל יכולות להעלות מספר סימני שאלה כאשר מבינים שברשת יש מספר ארכיטקטורות

1) Client/Server - השיטה הקלאסית שאנחנו מכירים, שרת תמיד ער עם IP קבוע בעוד שהלקוחות משתנים.
2) Peer 2 Peer - כל מחשב בתקשורת זאת הוא גם שרת וגם לקוח כאשר המערכות קצה הן שרירותיות וה IP של כולם הוא דינמי.
3) Hybrid - הלקוח משתף שרת בתוכן שלו והשרת מאפשר ללקוח להתחבר ללקוחות אחרים. 

הבעייתיות מתחילה כאשר חלק מהמכשירים מדברים אחד עם השני מבלי שפנו אליהם קודם אבל הם יושבים מאחורי NAT. במצבים מסוימים בקשות שיגיעו פשוט יחסמו בגלל המגבלות של שיטה זאת. 

### NAT Traversal Problem 
איך פותרים את הבעיות שעולות מהארכיטקטורות הנ״ל? למשל נסתכל על לקוח שרוצה לדבר עם הכתובת 10.0.0.1 שממופת לכתובת חיצונית 138.76.29.7. ב Full Cone היינו מצליחים אבל בכל שיטה אחרת נחסם. 

__פתרון 1__ - השרת שנמצאת מאחורי הNAT יוסיף רשומה סטטית לטבלת ה NAT שבאופן אוטומטי מעבירה בקשות מפורט וכתובת מסויימת למחשב מקומי שנרצה.

![Screenshot 2024-04-06 at 15.57.41.png|200](/img/user/Assets/Screenshot%202024-04-06%20at%2015.57.41.png)

__פתרון 2 -__ שימוש בשרת מתווך. מחשבים שמשתמשים באפליקציה מסוימת שולחים בקשה לשרת  מה שיגרום למיפוי בnat table ולקוחות שרוצים לדבר עם המחשבים הנ״ל ישלחו בקשות לשרת המתווך והוא יעביר אותם למחשבים וככה לא יחסם.

![Screenshot 2024-04-06 at 16.05.37.png](/img/user/Assets/Screenshot%202024-04-06%20at%2016.05.37.png)
נשים לב שכדי שזה יעבוד השרת עצמו לא צריך לשבת מאחורי NAT. כמובן גם שיש חסרון של איטיות ופרטיות, השרת המתווך לא יכול להבטיח הצפנה של המידע וכו׳.

__פתרון 3- Hole Punching__ 
איך מחשבים שלא רוצים תקשורת דרך שרת אבל עדיין יושבים מאחורי NAT יוכלו לדבר אחד עם השני? 

אליס ובוב רוצים לתקשר אחד עם השני ללא מתווך, בהתחלה נחזיק שרת Dir שהמטרה שלו היא לייצר חורים ב NAT וגם להחזיק מיפוי בין לקוחות שרוצים לדבר אחד עם השני.

אליס יעביר את הפרטים שלו ל Dir וככה יווצר 'חור' ב NAT (רשומה בטבלה) שלא חוסמת בקשות מDir. אליס מאוחר יותר תרצה להקים חיבור עם בוב ותבקש משרת ה Dir את הפרטים של המחשב של בוב וככה נוצר 'חור' גם בטבלה של המחשב שלה. 

הDir יעשה ״היכרות״ בין אליס ובוב על ידי כך שישלח בקשה לשניהם עם הפרטים של השני. כעת אליס יכולה לפנות לבוב, תשמור רשומה שלו בטבלה שלה, אבל החבילה תזרק אצל בוב, __למרות זאת__ במקביל, בוב שולח בקשה לאליס שומר את הרשומה אצלו בטבלה __אבל__ החבילה תגיע הפעם לאליס כי היא שמרה את בוב בטבלה, כעת הם יכולים לתקשר בינהם. 

![Screenshot 2024-04-06 at 16.16.22.png|300](/img/user/Assets/Screenshot%202024-04-06%20at%2016.16.22.png)
הטכניקה הנ״ל נקראת hole punching. 

## בעיית הניתוב 
כיצד ראוטר שרוצה להעביר בקשה למחשב יעד יודע מה המסלול הכי טוב __על גבי הרשת__ שפקטה צריכה לעבור? זאת אחת הבעיות ששכבת הרשת פותרת. שכבת הרשת ממדלת את הבעיה הזאת באמצעות [[Computer Science/Discrete Math/Graph theory basics\|גרף]].
הקודקוד הם ראוטרים והקשתות הם חיבורים בין ראוטרים קרובים (לפי הforward table).

![Screenshot 2024-04-06 at 16.39.23.png|200](/img/user/Assets/Screenshot%202024-04-06%20at%2016.39.23.png)

### OSPF routing 
Open Shortest Path First- פרוטוקול ניתוב שמשתמש באלגוריתם Shortest Path First ונמצא תחת קטגוריית אלגוריתמים מסוג link-state, כלומר כל כל ראוטר צריך להציף את מצב הערוצים לכל הראוטרים ששייכים לאותו [AS](https://en.wikipedia.org/wiki/Autonomous_system_(Internet)). ברגע שיש את המידע הזה ניתן לקבוע את העלות לפי מספר פרמטרים כמו bandwidth ו delay אבל החלק המרכזי כאן הוא שניתן לבצע דייקסטרה בגלל שלכל מחשב יש את כל טופולוגיית הרשת שלו ובאמצעות דייקסטרה אפשר לבנות את ה forward table.

הסיבוכיות של אלגוריתמים כאלה לעתים לא מאפשרת לנו להריץ אותם כל פעם בכל ראוטר כי זה כמו גדולה של זכרון וזמן, כמו כן הקשרים בין ראוטרים הם מאוד דינמיים. לכן מחלקים את האינטרנט לAutonomous System, אזור אוטונומי, ובכל אזור ניתן לקבוע באיזה אלגוריתם ניתוב להשתמש. כאשר רוצים לדבר עם נתב מחוץ לאזור האוטונומי שלך צריך להשתמש בפרוטוקול BGP עליו נדבר בהמשך. 

__Dijkstra's link-state routing algorithms__
[[Computer Science/Algorithms/Single-Source Shortest Paths (SSSP)\|דייקסטרה]] הוא אלגוריתם שפותר את בעית המסלולים הקצרים ביותר על גרף ממושקל ופרוטוקול OSPF מבוסס עליו. 
נסתכל על דוגמה- 
![Screenshot 2024-04-06 at 16.45.23.png](/img/user/Assets/Screenshot%202024-04-06%20at%2016.45.23.png)

1) מתחילים מקודקוד מקור, u ובודקים את השכנים שלו והעלות להגיע אליהן, מעדכנים בטבלה אם העלות להגיע אליהן כעת קטנה ממה שחישבנו קודם לכן(בשלב הראשון הכל $\infty$) ולוקחים את המינימלי מבינהם, במקרה הזה העלות של 3 לקודקוד w.
2) מבצעים כיווץ קודקודים של u ו w וכעת בודקים את השכנים של שניהם. ניתן לראות שהעלות להגיע לx יקרה יותר ולכן אם עושים זאת דרך w ולכן לא מעדכנים אבל להגיע ל v כן קצר יותר כי העלות היא 6 ולכן מעדכנים בטבלה.
3) ממשיכים כך עד שמכסים את כל הקודקודים. 
4) נשים לב שגם שומרים בטבלה מי הקודקוד שממנו הגענו כדי שנוכל לבנות מסלול.

נסתכל על דוגמה נוספת- 
![Pasted image 20240406165039.png|250](/img/user/Assets/Pasted%20image%2020240406165039.png)
ביצענו את האלגוריתם וקיבלנו את המסלולים הנ״ל, אם נפשט את זה נקבל 

![Screenshot 2024-04-06 at 16.50.59.png|250](/img/user/Assets/Screenshot%202024-04-06%20at%2016.50.59.png)

כעת עם הגרף הזה ניתן לבנות את הforward table. בהתאם ליעד, נוסיף את הממשק (השכן) שהכי קצר להגיע ממנו ליעד הסופי. למשל עבור הגרף הנ״ל הטבלה תיראה ככה

![Screenshot 2024-04-06 at 16.52.27.png|400](/img/user/Assets/Screenshot%202024-04-06%20at%2016.52.27.png)

1) ל v - הכי קצר להגיע דרכו ישירות.
2) ל x,y,w,z  - הכי קצר להגיע דרך x ולכן הם ימופו לאותו הלינק.

מה שהראנו עד כה זה לא הפרוטוקול ניתוב אלא רק חלק ממנו שמשתמש בדיקסטרה. נשים לב שכל נתב צריך להריץ דייקסטרה בעצמו וגם בעיות נוספת שעולות:
* איך ראוטר יודע איזה ראוטרים הם שכנים שלו בכלל?
* העלות יכולה להשתנות לפי traffic volume, כלומר אם המשקלים תלוים בעלות התעבורה שעברה בערוץ בזמן הרצת דייקסטרה. המצב הזה יכול לגרום לכך שכל הפקטות עוברות באותו מסלול מה שגורם בכל ריצה לכיוון של המסלול להתחלף
 
![Screenshot 2024-04-06 at 17.11.33.png](/img/user/Assets/Screenshot%202024-04-06%20at%2017.11.33.png)

### Routing Information protocol
RIP הוא פרוטוקול שמשתמש באלגוריתמים שמבוססים על וקטורי מידע (במקרה הזה distance vector כפי שמיד נראה) כדי לחשב את המסלול בין הראוטרים. 

__Distance vector algorithm__
משתמש במשוואת [[Computer Science/Algorithms/Single-Source Shortest Paths (SSSP)#Bellman-Ford Algorithm\|בלמן פורד]] ולא מצריך את כל מצב הערוצים בגרף אלא כל ראוטר יעביר לשכניו את וקטור המרחקים שלו. וקטור המרחקים הוא וקטור שמראה לאן הם יודעים להגיע ובאיזה עלות. נזכיר שמשוואת בלמן פורד אומרת 

$$D_{x}(y)= \min_{v}\{c_{x,v}+ D_{v(y)}\}$$
כלומר העלות המינימלית מ x ל y היא המינימום מבין העלות של x להגיע לשכן שלו v + עלות ההגעה מ v ל y.

נסתכל על דוגמה שבה כל הקודקוד x,v,w מדווחיםל u את העלות המינימלית שלהם לz
![Screenshot 2024-04-06 at 19.03.04.png|250](/img/user/Assets/Screenshot%202024-04-06%20at%2019.03.04.png)

מתקיים 
$$D_{u}(z)= \min (c_{u,v}+ D_{y}(z), c_{u,x  }+ D_{x}(z),c_{u,w}+D_{w}(z))=4$$

1) נשים לב שבשיטה הזאת נוכל להגיע למצב של מעגלים כי אין לנו מידע על כל הגרף.
2) כמו כן, גם כאן אם המידע משתנה קודקודים צריכים לעדכן את שכניהם בוקטור המעודכן אבל זה דורש פחות עדכונים מאשר להריץ דייקסטרה מחדש.

נסתכל על דוגמה נוספת-
![Screenshot 2024-04-06 at 19.11.12.png](/img/user/Assets/Screenshot%202024-04-06%20at%2019.11.12.png)

1) ניתן לראות שוקטור המרחקים של x, y, z מכיל רק את המרחקים לשכנים שלהם בהתחלה ובכל האחרים שם $\infty$ .
2) בשלב הראשונים כל אחד מדווח את וקטור המרחקים שלו לשני שכניו. הם מריצים את משוואת בלמן פורד וניתן לראות שכתוצאה מהרצת המשוואה וקטור המרחקים של x השתנה וגם של z.
3) כתוצאה מהעדכון שניהם שולחים את וקטור השכנים המעודכן לשכנים שלהם (x, y עבור z ו z, y עבור x) , y לא שולח מחדש כי הוא לא עדכן.
4) כעת כל מי שקיבל את וקטור המשתנים המעודכן, מריץ בדיקה ורואה ששום דבר לא השתנה והאלגוריתם נעצר.

_link cost changes:_ 
כפי שאמרנו קודקודים שעלותם משתנה מעדכנים את השכנים שלהם והם צריכים לחשב את הוקטור שלהם מחדש. נשים לב לתופעה מעניינת ״חדשות טובות מתפשטות מהר״. נדגים למשל עם הגרף הבא:
![Screenshot 2024-04-06 at 19.28.41.png|200](/img/user/Assets/Screenshot%202024-04-06%20at%2019.28.41.png)

1) בהתחלה y מזהה את השינוי ומעדכן את הוקטור שלו.
2) לאחר מכן , y מתריע על כך ל z שמשנה גם הוא את העלות שלו ל x ושולח הודעה לשכנים.
3) y מקבל את המידע והעלות שלא לא משתנה אז הוא מפסיק להפיץ.

אבל כמו שחדשות טובות מתפשטות מהר ככה גם ״חדשות רעות מתפשטות לאט״:
![Screenshot 2024-04-06 at 19.41.31.png|200](/img/user/Assets/Screenshot%202024-04-06%20at%2019.41.31.png)

1) y רואה את השינוי אבל רואה שz מגיע ל x בעלות 5. מסיבה זאת y מודיע לz שהעלות החדשה שלו לx תהיה 6 דרך z.
2) z מזהה שהעלות לx דרך y עולה 6 אז z מחשב מחדש שהעלות שלו היא 1 לy + העלות מ y ל x שזה 6 כלומר סך הכל 7.
3) y מזהה את העלות החדשה מ z ל x כלומר 7 ומחשב מחדש עלות של 8.
4) התהליך הזה חוזר שוב ושוב עד שהעלות עולה על __50__ , רק בשלב הזה z ו y יבינו שהמסלול בכלל ל x הוא מצד השני.

התופעה הזאת נקראת __count to infinity__ 

__אז איך RIP משתמש באלגוריתם הזה?__
1) המשקלים בין הקשתות הם תמיד 1.
2) כל 30 שניות שולחים לשכנים את וקטור המרחקים גם אם הוא לא השתנה.
3) אם אחרי 180 לא התקבל עדכון משכן, מבחינת אותו ראוטר הקשת כבר לא קיימת ומעדכנים את הטבלה כאילו הוא לא קיים.
4) כדי להמנע ממצב של count to infinity משתמשים בשיטה שנקראת poison reverse, בשיטה זאת מגדירים שהמרחק הכי רחוק למסלול הוא 16. כלומר מגבילים את אורך המסלול הארוך ביותר להיות 16 וככה גם יודעים שזה הcount to infinity הארוך ביותר האפשרי.

### חישובים בבעיות הניתוב
נסתכל על הגרף הבא-
![Screenshot 2024-04-06 at 21.49.34.png|400](/img/user/Assets/Screenshot%202024-04-06%20at%2021.49.34.png)

הגרף מכיל את הנתונים הבאים: 
![Screenshot 2024-04-06 at 21.50.05.png](/img/user/Assets/Screenshot%202024-04-06%20at%2021.50.05.png)

1) A רוצה להוריד קובץ בגודל 5KB מ G ב HTTP1.1. מה הנתיב שיעברו בין החבילות בעזרת RIP? 
2) A רוצה להוריד 2 קבצים מ G בגודל 3KB כל אחד באזרת OSPF ב HTTP1.1.
3) אותו הדבר אבל הפעם D הוא פרוקסי.

נבין כיצד ניגשים לבעיה הזאת. ראשית, מכיוון ש RIP הוא פרוטוקול מסוג Distance Vector (DV) אזי כל נתב לומד את המרחקים לכל היעדים דרך שכניו. בRIP אנחנו מעדיפים את המסלול הקצר ביותר מבחינת מספר הקפיצות. לאחרמ ספר סיבובים תחנה A תלמד מתחנה D שהיא יכולה להגיע דרכה ל G במסלול הקצר ביותר. 

נזכיר ש[[Computer Science/Networks/Transport Layer#היחס בין גודל החלון וקצב השידור\|במהלך השידוך היחס בין גודל החלון וקצב השידור מתהפכים]] בהתאם לנוסחה 

$$2^{i-1}\cdot d_{tran}\geq RTT$$

אם נציב לפי הנתונים שקיבלנו יתקיים

$$\displaylines{
2^{i-1}\cdot \frac{10^{3}B}{10^{6}Bps} \geq  2\cdot \frac{(10^{3}+40)B}{10^{6}Bps}+ 2\cdot \frac{2\cdot 10^{4}m}{2\cdot 10^{8}mps}+ 2\cdot \frac{2\cdot 10^{5}m}{2\cdot 10^{8}mps} \\ 2^{i-1}\cdot 10^{-3}\geq 4.28 ms\to i>3
}$$

* המכפלות פי 2 זה בגלל שעוברים שתי ראוטרים עד שמגיעים ליעד ובחזרה. A ל G דרך D ובחזרה. 
* כלומר, כאשר __גודל החלון__ גדול יותר מ4 חבילות. אבל, יש לנו סך הכל 5 חבילות לשדר (כי הקובץ הוא 5 וה mss הוא 1) כך שלא נגיע לזה. 
* סך הכל שידרנו 3 חלונות ולכן הזמן כולו היה 

$$3RTT+10^{-5}+\text{ connection establishment}$$


כעת לסעיף השני, משתמשים כעת ב OSPF כלומר צריך לחשב את משקלי הקשתות, השהיית ההתפשטות לכל קשת. נקבל:

![Screenshot 2024-04-06 at 22.28.11.png|250](/img/user/Assets/Screenshot%202024-04-06%20at%2022.28.11.png)

כעת המסלול הקצר ביותר הוא $A \to B \to F \to G$. נשים לב שמכיוון שמדובר בחיבור persistent אזי נוכל לבקש את שני המשאבים באותו חיבור, לא נצטרך שני חיבורים נפרדים. אם מדובר בחיבור pipelining אז נוכל לשלוח את שתי הבקשות אחת אחרי השנייה בלי לחכות. אם מדובר בחיבור ללא pipelining, אזי נבקש משאב, נוריד אותו ואז נבקש את המשאב הבא על גבי אותו חיבור וננצל את גודל החלון. אם היינו צריכים לפתוח חיבור נפרד, גודל החלון היה מתאפס בחיבור החדש.

נשים לב, שהורדת המשאב הראשון תהיה בעזרת החלון החילון והשני בחיבור ואילו הורדת המשאב השלישי תהיה בעזרת החלון השלישי בלבד. 

לגבי הסעיף האחרון, כעת יש פרוקסי, אזי A יפתח חיבור TCP מול הפרוקסי ויבקש את המשאב ממנו. D יפתח חיבור נפרד מול G ויבקש את המשאב. יוריד את המשאב ואז יעביר אותו ל A.

## BGP 
Border Gateway protocol הוא פרוטוקול ניתוב בין AS.
* בתוך כל AS יהיה BGP Router. ראוטרים מסוג זה שיהיו שכנים יחליפו בינהם הודעות בחיבור TCP שהוא semi permanent. 

![Pasted image 20240412002000.png](/img/user/Assets/Pasted%20image%2020240412002000.png)
* AS3 מפרסם דרך 3a שהוא ה Border gateway לשכן שלו AS2 שכדי להגיע לראוטר x עליו להגיע ל 3a ומשם זה יגיע ליעד.
* במילים אחרות, AS3 מבטיח ל AS2 שדרכו המידע יגיע לx.
* 2c שהוא הborder gateway של AS2 צריך לקבל את המידע ולדווח אותו לכל הראוטרים בAS2 (זה נקבע מראש ב policy של AS2). כמו כן בpolicy נקבע שראוטר גבול נוסף של AS2 שהוא 2a צריך לפרסם את המסלול (AS2,AS3,x) ל AS1.
* אין צורך לפרסם אם אני מופיע בתוך המסלול.
* באותו אופן ש AS2 פרסם ל AS1 את המסלול גם AS3 יכול לפרסם את המסלול ל AS1 לפי המדיניות.
![Pasted image 20240412003042.png](/img/user/Assets/Pasted%20image%2020240412003042.png)
* במצב זה AS1 בוחר את המסלול שמתאים ל policy שלו (לאו דווקא הקצר ביותר) ואת מה שבחר יפרסם הלאה, במקרה הזה בחר את AS3,x. 

גם את הAS עצמם נוכל לחלק לתתי קטגוריות
* provider network
* customer network 
אלו מקיימים בינהם יחסי גומלין: 
![Screenshot 2024-04-12 at 0.38.52.png](/img/user/Assets/Screenshot%202024-04-12%20at%200.38.52.png)

על בסיס היחסי גומלין האלה רשתות יחליטו האם לפרסם מסלולים או לא. למשל כאן B לא יפרסם ל C שניתן להגיע ל w דרכו ו x לא יפרסם לאף אחד כי הוא ״לקוח״ של C.
1) A,B,C הם providers 
2) x,w,y הם customer
3) ל x יש שני providers.

__חוקי publish של BGP:__
* customers משלמים לProvider
* בין Peers אין תשלום.
* אם הsource (מי שפרסם אליי) הוא לקוח - נפרסם.
* אם הsource הוא peer/provider: נפרסם רק ל customers.

>[!warning] BGP Security
אין ולידציה על advertisements מה שיכול לגרום לאנשים לפרסם שהם מחזיקים בכתובות שהם לא באמת מחזיקים.

__דוגמה:__
![Screenshot 2024-04-12 at 1.50.33.png](/img/user/Assets/Screenshot%202024-04-12%20at%201.50.33.png)
![Pasted image 20240412102610.png](/img/user/Assets/Pasted%20image%2020240412102610.png)

![Pasted image 20240412103236.png](/img/user/Assets/Pasted%20image%2020240412103236.png)

