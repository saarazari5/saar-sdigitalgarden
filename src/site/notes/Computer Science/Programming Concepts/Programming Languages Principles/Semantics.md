---
{"dateCreated":"2024-01-20 21:51","tags":["programming_language"],"pageDirection":"rtl","dg-publish":true,"permalink":"/computer-science/programming-concepts/programming-languages-principles/semantics/","dgPassFrontmatter":true}
---


# סמנטיקה
חשוב שנדע להבדיל בין סינתקס של שפה לבין שמייצג את המבנה של השפה, סדר מילים וסימנים והרכבת משפטים שמהווים תוכנית מבחינת נכונות שלהם בסדר המילים. 
הסמנטיקה היא המשמעות של אותם המילים, מה הן אומרות מבחינת התוכנית שלנו. 

למשל נסתכל על הקוד הבא:
$$z:=x;x:=y;y:=z$$
מבחינת ניתוח סינתקס של התוכנית נוכל להבין שיש כאן 3 הצהרות (לפי ההפרדה של התו ;). כל אחת מהן מכילה משתנה בצד אחד עם אופרטור = ולאחר מכן מה שנראה כ expression שהוא בעצמו משתנה. 

__הסמנטיקה__ מתעסקת עם המשמעות הדקדוקית והנכונות הדקדוקית של תוכניות. כלומר, הסמנטיקה תבין שהמשמעות של התוכנית היא החלפת הערכים $x,y$ תוך השמה של $z$ להיות הערך הסופי של $y$.

ישנם מספר דרכים לפרמל את ההצהרה הנ״ל בגדול יש 3 דרכים עיקריות 
	- _סמנטיקה תפעולית (Operational Semantic):_ המשמעות של מבנה מוגדרת על ידי החישוב שלו כאשר הוא מורץ על ידי מחשב.
	- _סמנטיקה דנוטציונית:_ משמעויות מעוצבות על ידי אובייקטים מתמטיים המייצגים את ההשפעה של ביצוע המבנים (למשל על ידי פונקציות).
	- _סמנטיקה אקסיומטית:_ מושפעת מ assertions. התוכנית יכולה להיות נכונה באופן חלקי אבל מוסיפים לה תכונות של preconditions ו postconditions כך שאם התוכנית מסתיימת אנחנו יודעים שהתנאים האלו התקיימו וקיבלנו תוצאה רצויה. 

>[!info] בשביל מה חשובה הסמנטיקה?
>מעבר לפאן התאורטי שהיא נותנת לנו את היכולת לתת משמעות לתוכניות היא גם נותנת לנו כלי פרקטי לכתוב כלים שמפרשים שפות תכנות (interpreters)
## שפת while
שפה __אימפרטיבית__ פשוטה שעוזרת להדגים ולהסביר עקרונות סמנטיים כפי שציינו למעלה.
__התחביר האבסטרקטי__ של while מחולק לקטגוריות הבאות 
	- Num- קבוצת המספרים השלמים
	- Var- קבוצת המשתנים
	- Aexp- קבוצת הביטויים האריתמטיים
		- $\forall_{n\in Num}:n\in Aexp$ 
		- $\forall_{x\in Var}: x\in Aexp$
		- $\forall_{a_{1},a_{2}\in Aexp}:a_{1}+a_{2},a_{1}-a_{2},a_{1}\cdot a_{2}\in Aexp$ 
	- Bexp- קבוצת המשתנים הבוליאנים נגדיר ביטוי בוליאני להיות $b::=true|false|a_{1}=a_{2}|a_{1}\leq a_{2}|\neg{b}|b_{1}\wedge b_{2}$ 
	- Stm- קבוצת הפקודות
		- אם $x\in Var$ ו $a\in Aexp$ אז $x:=a\in Stm$ 
		- $skip\in Stm$ 
		- $\forall_{S_{1},S_{2}\in Stm}: S_{1};S_{2}\in Stm$ 
		-  `if b then S1 else S2`.
		- `while b do S` 
	הערה: בזכות הסעיף השלישי Stm זאת קבוצת התוכניות.
	
![Screenshot 2024-01-22 at 14.24.10.png](/img/user/Assets/Screenshot%202024-01-22%20at%2014.24.10.png)
חשוב לשים לב שזהו סינתקס אבל את הסמנטיקה אנחנו יכולים לקבוע, למשל יכלנו לקבוע ש $n::= 0|1|n\ 0| n\ 1$ כלומר $n$ הוא מחרוזות המספרים הבינאריים. מגדירים זאת באמצעות __פונקציות סמנטיות__ ובמקרה של מספרים $N: Num\to Z$. 

## AST
התחביר האבסטרקטי מתאר איך לבנות expressions בשפה מבלי לרדת לפרטים של keywords , הזחות וכו׳. מתחביר אבסטרקטי אפשר לבנות Abstract Syntax Trees שמייצג את המבנה הבסיסי ביותר של התוכנית. אפשר לבנות אותו מבלי לבדוק כל פרט שרלוונטי ל concrete syntax אם כי יכול להיות מצב שיווצרו לנו שתי AST מאותה תוכנית והסינתקס הקונקרטי יצטרך להכריע.

![Pasted image 20240120235613.png](/img/user/Assets/Pasted%20image%2020240120235613.png)

בגלל שלא נרצה לכתוב עצי סינתקס לכל תוכנית (ראו איך התוכנית הבסיסית הנ״ל יצרה עץ די גדול יחסית) נרצה לייצג אותם באמצעות  __תחביר ליניארי__ לשם כך נשתמש ב _סוגריים_. למשל 

$$z:=x;(x:=y;y:=z)$$

יבטא את העץ השמאלי בתמונה ו 

$$(z:=x;x:=y);y:=z$$

יבטא את העץ הימני.

לדוגמה, נבנה עת סינתקס עבור התוכנית הבאה: 
```While
y:=1;
while not(x=1) do (
	y:=y*x;
	x:=x-1;
)
```


![Screenshot 2024-01-21 at 16.37.13.png|450](/img/user/Assets/Screenshot%202024-01-21%20at%2016.37.13.png)
## Semantic Functions
בסופו של דבר הסינתקס האבסטרקטי מורכב מ[[Computer Science/Programming Concepts/Programming Languages Principles/OCaml#Expressions, Values and Types\|expressions]] אבל המשמעות של ביטוי כזה נקבע לפי הערך של המשתנים שנמצאים בתוך הביטוי הזה. 

לשם כך נגדיר states שזאת תהיה פונקציה ממשתנה לערך שלו 

$$State=Var\to Num$$

אם $s$ הוא מצב ו $x$ הוא משתנה נסמן את $s(x)$ כ $s \ x$ . נשים לב שבגלל שאנחנו מגדירים את זה כפונקציה אנחנו בהכרח כופים על כל משתנה לקבל ערך אחד מהגדרה ח״ע.

__סמנטיקה של ביטויים אריתמטיים:__
כעת, בהינתן ביטוי אריתמטי $a$ ומצב $s$ נוכל כעת לקבוע את הערך של הביטוי. 
נגדיר __פונקציה שלמה__ $A:Aexp\to (State\to Num)$ באופן הבא:

a) $\forall_{n\in Num}: A[n]s=n$
b) $\forall_{x\in Var}: A[x]s=s \ x$
c) $A[a_{1}+a_{2}]= A[a_{1}]s+A[a_{2}]s$ 
d) כפל וחיסור דומה לסעיף הקודם.

נשים לב להבדלה בין הסימנים בצד שמאל ולסימנים האריתמטיים בצד ימין. צד שמאל הם סימנים של חלק מהסינתקס האבסטרקטי ובצד ימין זה ביטויים אריתמטיים כפי שאנחנו מכירים. 

__דוגמה:__ 
נניח שיש מצב $x$ המקיים $s\ x=3$ . נחשב את $A[x+1]s$. לפי הכללים הנ״ל מתקיים $A[x+1]s=A[x]s+A[1]s= s(x)+1= 3+1 =4$ .

__סמנטיקה של ביטויים בוליאנים:__
נגדיר אותה כפונקציה $B:Bexp\to(s\to\{tt,ff\})$ על ידי:
a) $B[false]s=ff$
b) $B[true]s=tt$
c) $B[a_{1}=a_{2}]s=\begin{cases} tt & A[a_{1}]s=A[a_{2}]s \\ ff & else \end{cases}$
d) $B[a_{1}\leq a_{2}]s=\begin{cases} tt & A[a_{1}]s\leq A[a_{2}]s \\ ff & else \end{cases}$
e) $B[\neg{b}]s=\begin{cases}tt & B[b]s=ff \\ ff & else\end{cases}$
f) $B[b_{1}\wedge b_{2}]s=\begin{cases}tt & B[b_{1}]s=tt\ and \ B[b_{2}]s=tt \\ ff & else\end{cases}$

## Natural Semantic
סמנטיקה טבעית היא אחת הדרכים לתאר __סמנטיקה של פקודות__. בסמנטיקה של פעולות אנחנו מתעניינים בשינויי המצבים במהלך הרצה של תוכנית. הסמנטיקה הטבעית שמה בחשיבות עליונה את התוצאה הסופית של הריצה של התוכנית שלנו ואיך תוצאה זאת מושגת. 

המטרה של statements ב while זה לשנות את הstates. למשל אם $x=3$ במצב $s$ ואנחנו מריצים את הפקודה $x:=x+1$ אז אנחנו מקבלים מצב חדש שבו $x=4$ . לכן, בעוד שסמנטיקה של ביטויים אריתמטיים ובוליאניים רק משקיפה על הstate ומאפשרת לנו לחשב אותו , הסמנטיקה של פעולות גם תשנה את הstate הזה. בסמנטיקה תפעולית (ובפרט גם טבעית) החשיבות היא גם על איך התוכנית רצה ולא רק התוצאות של הריצה. ליתר דיוק, העניין הוא סביב כיצד המצבים משתנים במהלך ריצת התוכנית.

בסמנטיקה טבעית מתעניינים בקשר בין __המצב ההתחלתי__ של תוכנית __למצב הסופי__ שלה. 

נגדיר כמה כללים של סמנטיקה של פקודות (Operational Semantic)
יהי $s$ מצב , $y$ משתנה ו $v$ מספר, המצב $s[y\mapsto v]$ יוגדר על ידי :

$$s[y\mapsto v] x=\begin{cases}
v & x=y\\ s\ x & else
\end{cases}$$
(המשמעות הסמנטית היא כאשר המשתנה $y$ ממופה לערך $v$ מה יהיה הפלט של הפונקציה $s \ x$) .

זה מבוסס על __עקרון ההחלפה__. זה בעצם $s$ רק ש $y$ כבול לערך $v$.

![Pasted image 20240122003944.png](/img/user/Assets/Pasted%20image%2020240122003944.png)

הסמנטיקה התפעולית מבוססת על היגדים מהצורה $\langle S,s\rangle\to s^{\prime}$  האינטואיציה של זה היא שכאשר אנחנו במצב $s$ מפעילים את הפקודה $S$ ועוברים למצב $s^{\prime}$ . 

נגדיר מספר כללי היסק עבור היחס $\to$ : 

![Pasted image 20240122010109.png](/img/user/Assets/Pasted%20image%2020240122010109.png)

נוכל להוסיף כללים חדשים לסמנטיקה שלנו, למשל נגדיר `if(x:=e) then S1 else S2` ככלל חדש ונוכל לכלול אותו בסמנטיקה שלנו כך :

![Pasted image 20240122144829.png](/img/user/Assets/Pasted%20image%2020240122144829.png)

נוסיף כלל נוסף גם `case(b1:S1),(b2:S2),(else:S3)`

![Screenshot 2024-01-22 at 14.49.27.png](/img/user/Assets/Screenshot%202024-01-22%20at%2014.49.27.png)

לחוק (כפי שרשום למעלה) יש את התצורה הכללית :
![Pasted image 20240122010235.png](/img/user/Assets/Pasted%20image%2020240122010235.png)
כאשר $S_{1},\dots S_{n}$ הם מרכיבים מידיים של $S$ או שהם פקודות שנוצרות מרכיבים מידיים של $S$. 
לכלל יש הנחות (מה שרשום מעל הקו) ומסקנה אחת (מתחת לקו) כמו כן יכול להיות לכללים גם תנאים בוליאנים. אפשר להסתכל על החלק העליון כגזירה של החלק התחתון. בעצם  if, while, comp הם כללי גזירה ו ass, skip הם אקסיומות.

__כללים ללא הנחות נקראים אקסיומות__ למשל $ass$ . 

### עצי גזירה
נגדיר את עץ הגזירה של $\langle S,s\rangle\to s^{\prime}$ הוא עץ ששורשו הוא $\langle S,s\rangle\to s^{\prime}$ העלים הם אקסיומות וכל קודקוד הוא מסקנה מילדיו לפי אחד מכללי הגזירה.

_עצים גזירה מציירים כאשר השורש למטה_.

__הגדרה:__ ההיגד $\langle S,s\rangle\to s^{\prime}$ מתקיים אם יש עץ גזירה ששורשו הוא $\langle S,s\rangle\to s^{\prime}$.
נסתכל על הדוגמה הבאה:

יהי $s_{0}$ מצב כך ש $s_{0}x=5$ ו $s_{0}y=7$ .נסמן $s_{1}:s_{0}[z\mapsto 5], s_{2}:s_{1}[x\mapsto7],s_{3}:s_{2}[y\mapsto 5]$ נסתכל על הפקודה הבאה 

$$\langle (z:=x;x:=y);y:=z,s_{0}\rangle$$

נרצה להראות שזאת תוביל אותנו ל $s_{3}$ .
נבנה עץ גזירה 

![Pasted image 20240122125327.png](/img/user/Assets/Pasted%20image%2020240122125327.png)

__משפט:__ אם $<S,s>\to s^{\prime}$ אז עבור  $s^{\prime\prime}$  מתקיים שאם $<S,s>\to s^{\prime\prime}$ אז $s^{\prime}=s^{\prime\prime}$ .

__הוכחה:__ 
אפשר לעשות את זה ב [[Computer Science/Programming Concepts/Programming Languages Principles/Structural induction\|אינדוקציה על מבנה עץ הגזירה]] של $<S,s>\to s^{\prime}$ . 

_בסיס:_ נבדוק על כל אחת מהאקסיומות. 
a) אם הגזירה הנ״ל מובילה אותנו ל skip לאחר הפעלה יחידה, זה אומר ש $S=skip$ ולכן זה אומר $s^{\prime}=s$. כיוון ש $S=skip$ אז אם נניח $<S,s>\to s^{\prime\prime}$ נקבל $<skip,s>\to s^{\prime\prime}=s=s^{\prime}$ כדרוש.

b) אם $<S,s>\to s^{\prime}$ נגזר על ידי עץ הגזירה עם הפעלה יחידה של כלל ass. במקרה זה $S$ חייבת להיות מהצורה $x:=a$ ולכן מתקיים $s^{\prime}=s[x\mapsto A[a]s]$. כעת אם נניח ש $<S,s>\to s^{\prime\prime}$ נקבל באותה צורה $s^{\prime\prime}=s[x\mapsto A[a]s]=s^{\prime}$ __כדרוש.__ 

נשים לב ש $skip$ ו $while^{ff}$ דומים זה יוצא אותה הוכחה.

_צעד 1:_ 
ל $<S,S>\to s^{\prime}$ יש עץ גזירה שבו הכלל האחרון שהופעל הוא $Comp$ אז העץ הוא 

$$\frac{<S_{1},s>\to s_{0} \ \ <S_{2},s_{0}>\to s^{\prime}}{<S_{1};S_{2},s>\to s^{\prime}}$$
עבור $s_{0}$ כלשהו. 

כלומר קיימים $S_{1};S_{2}$ כך ש $S=S_{1};S_{2}$

כעת נניח ש $<S,s>\to s^{\prime\prime}$ עץ הגזירה ייראה כך 

$$\frac{<S_{1},s>\to s_{1} \ \ <S_{2},s_{1}>\to s^{\prime\prime}}{<S_{1};S_{2},s>\to s^{\prime\prime }}$$

עבור $s_{1}$ כלשהו. 

מהנחת האינדוקציה נוכל להסיק ש כיוון ש $<S_{1},s>\to s_{1}$ וגם $<S_{1},s>\to s_{0}$ אז $s_{0}=s_{1}$ ולכן $<S_{2},s_{1,0}>\to s^{\prime\prime}=s^{\prime}$ כדרוש.  

_נשים לב שההנחה היא רק על עץ הגזירה הראשונה ולא השני_.
__יתר הכללים עובדים בצורה דומה__.

בגדול המשמעות של האינדוקציה היא לסקור את כל המבנים האפשריים החל מהאקסיומות ועד לכללים, אם נראה על כל האקסיומות והכללים הבסיסיים שמפורטים בטבלה למעלה שהמשפט מתקיים, אז הוא כמובן מתקיים על כל צירוף שלהם.

__לסיכום:__
כדי להוכיח שמתקיימת תכונה מסוימת על סמנטיקה נשתמש באינדוקציה על __צורת העץ__ כאשר הבסיס הוא התכונה המתקימת על האקסיומות ובצעד האינדוקציה לכל כלל גזירה נניח שמתקיימת התכונה ונוכיח למסקנה של הגזירה שהתכונה מתקיימת. 
#### הוכחת שקילות סמנטית
נרצה להראות שקילות סמנטית בין שני קטעי קוד בשפת while 
`while b do S ~ if b then (S; while b do S) else skip`

לשם כך נצטרך להוכיח את שתי הטענות הבאות :

![Screenshot 2024-01-22 at 19.23.39.png](/img/user/Assets/Screenshot%202024-01-22%20at%2019.23.39.png)

מזכיר הוכחה של שיוויון על ידי הכלה דו כיוונית. נרצה להראות שאם אחד נגזר למצב $s^{\prime\prime}$ אז גם השני נגזר לאותו מצב.

נעשה כיוון אחד, הכיוון השני דומה. מתקיים אם כן, $<while \ b\ do \ S,s>\to s^{\prime\prime}$ אזי, ישנו עץ גזירה $T$ שגוזר את הכלל הזה. נחלק למקרים:

a) אם $B[b]s=tt$ במקרה זה עץ הגזירה נראה מהצורה

![Screenshot 2024-01-22 at 19.29.01.png](/img/user/Assets/Screenshot%202024-01-22%20at%2019.29.01.png)

כאשר $T_{1}=<S,s>\to s^{\prime}$ ו $T_{2}$ הוא מהצורה $<\text{while b do S, }s^{\prime}>\to s^{\prime\prime}$. 

נוכל לבצע comp על T1,T2 ונקבל :

![Screenshot 2024-01-22 at 19.31.38.png](/img/user/Assets/Screenshot%202024-01-22%20at%2019.31.38.png)

כעת בגלל ש$b=tt$ נוכל להשתמש בכלל $if^{tt}$ ונקבל 

![Screenshot 2024-01-22 at 19.33.16.png](/img/user/Assets/Screenshot%202024-01-22%20at%2019.33.16.png)

שמנו skip כי אין לו חשיבות כיוון ש $b$ הוא תמיד true.

b) כאשר $B[b]=ff$ העץ גזירה הוא מהצורה $<\text{while b do S, s}>\to s$  
במצב זה אנחנו נשארים באותו מצב ולכן נגדיר $s=s^{\prime\prime}$ . נוכל לנצל זאת כדי להשתמש ב $\text{<skip, s>}\to s$  ונשתמש בזה ובכלל $if^{ff}$ כדי לגזור מהכלל הזה את $\text{<if b then S1 else S2,s>}\to s^{\prime}$ כדי לקבל

![Screenshot 2024-01-22 at 19.39.27.png](/img/user/Assets/Screenshot%202024-01-22%20at%2019.39.27.png)ֿ
