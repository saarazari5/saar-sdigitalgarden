---
{"dateCreated":"2024-02-11 14:49","tags":["programming_language"],"pageDirection":"rtl","dg-publish":true,"permalink":"/computer-science/programming-concepts/programming-languages-principles/lambda-calculus/","dgPassFrontmatter":true}
---

# תחשיב למדא
תחשיב למדא הוא צורה לוגית-פורמלית להצגה וטיפול בפונקציות במתמטיקה ומדעי המחשב. 

תחשיב למדא הוא מודל חישובי שעל פי [[Computer Science/Computational Models/Turing Machine\|תזת צ'רץ'-טיורינג]] הוא שלם טיורינג כלומר הוא שקול ל [[Computer Science/Computational Models/Turing Machine\|מכונת טיורינג]] . 

סימון למדה הוא ביטוי מהצורה $f=\lambda x.f(x)$ כאשר האיבר אחרי הנקודה הוא כלל התאמה שבדרך כלל מוצג כביטוי של $x$. למשל את הפונקציה של שורש ריבועי נרשום כך: $\lambda x.\sqrt{x}$ .

==הגדרה: ==
הביטויים בתחשיב $\lambda$ מוגדרים באופן הבא:
__א)__ __משתנה:__  $x,y,z$ ... כל משתנה הוא ביטוי.
__ב)__ __Abstraction:__ אם $x$ הוא משתנה ו $t_{1}$ הוא ביטוי אז $\lambda x.t_{1}$ הוא ביטוי שנקרא ״אבסטרקציה״ לדוגמה: $\lambda x.x+1$
__ג)__ __Application:__ אם $t_{1},t_{2}$ הם ביטויים אז $t_{1}t_{2}$ הוא ביטוי ״הפעלה״ לדוגמה: $(\lambda x.x+1)3$ 

>[!note] 
>סוגריים שהושמטו בהפעלות חודרות שמאלה למשל $t_{1}t_{2}t_{3}=(t_{1}t_{2})t_{3}$ 

==הגדרה: ==
בביטוי $\lambda x.t$ כל מופע של $x$ ב $t$ נקרא _קשור_. $x$ נקרא _חופשי_ אם אינו קשור.
לדוגמה, $xy$ הוא ביטוי שבוא גם $x$ וגם $y$ חופשיים אבל ב $\lambda y.xy$ מתקיים ש $x$ חופשי ו $y$ קשור

## קומבינטור
ביטוי ללא משתנים חופשיים נקרא קומבינטור. 

==הגדרה: ==
קומבינטור הזהות הוא $\lambda x.x$ ונסמנה $id$ . 
## כלל אלפה
כלל זה אומר ש $\lambda x.f(x)=\lambda y.f(y)$  ומשמעותו הוא ש למדא הוא כמת לוגי קושר. כלומר, מותר לשנות את השם של המשתנה הקשור, כך עוד מחליפים את שמו לשם של משתנה המופיע חופשית.
## כלל בתא
רדוקציית $\beta$ מוגדרת כך:
$$(\lambda x.t_{12})t_{2}\to t_{12}[x\mapsto t_{2}]$$

כאשר $t_{12}[x\mapsto t_{2}]$ הוא הביטוי המתקבל מ $t_{12}$ על ידי החלפת כל מופע __חופשי__ של $x$ ב $t_{2}$ , זה נקרא __substitution__ .

המשמעות היא שהפעלה של הפונקציה על איבר כלשהו מחזירה את התמונה של אותו איבר לפי כלל ההתאמה של הפונקציה. במילים אחרות, זה כלל הצבה לחישוב הערך שמחזירה הפונקציה.

_נשים לב_ שמחפשים משתנים חופשיים ב $t_{12}$ ולא ב $\lambda x.t_{12}$ . זה עוזר בהמשך כאשר נתעסק עם למדות שמפעילות למדות אחרות. 

_דוגמה:_
$(\lambda x.x)y\to y$ , $(\lambda x.x+3)7\to 10$ 

בהקשר לנאמר למעלה על ביטויים חופשיים, נסתכל על הדוגמה הבאה $(\lambda x.x(\lambda x.x))(u r)$ .

אנחנו כעת מסתכלים על הביטוי $x(\lambda x.x)$ ורוצים להפעיל עליו את $ur$ ה $x$ הראשון הוא חופשי אבל הוא מכיל בתוכו ביטוי למדה (שלא הופעל, כלומר יש פה הגדרה של פונקציה פנימית אם נחשוב על זה מנקודת מבט תכנותית)  ולכן הפלט יהיה $ur(\lambda x.x)$ .

## תכנות בתחשיב למדא
פונקציה עם כמה ארגומנטים מתנהגים כמו ב[[Computer Science/Programming Concepts/Programming Languages Principles/OCaml\|OCaml]] : 
$$\lambda x.\lambda y.t = \lambda x.(\lambda y.t)$$

__ביטויים בוליאניים__ 
__הגדרה:__ הקומבינטורים tru ו fls מוגדרים כך :

$$\displaylines{
tru = \lambda t.\lambda f.t \\
fls = \;\lambda t.\lambda f.f
}$$

במילים אחרות זאת פונקציה שמקבלת שני ארגומנטים ומחזירה את הראשון עבור tru ועבור fls זאת פונקציה שמקבל שני ארגומנטים ומחזירה את השני.

נוכל להגדיר אופרטורים יותר מורכבים למשל $Not = \lambda b.b \ fls \ tru$ 
==הגדרה: ==
נגדיר את הקומבינטור test להיות 

$$test= \lambda l.\lambda m.\lambda n.lmn$$

נראה דוגמה 

$$\displaylines{\text{ test tru v w}= (\lambda l.\lambda m.\lambda n.lmn)\text{true v w}\to \\ (\lambda m.\lambda n.\text{tru m n})\text{v w}\to\\ 
(\lambda n.\text{tru v n})w\to \text{tru v w}\to \text{v}
}
$$

הפיתוח הוא לפי רדוקציית $\beta$ עליה דיברנו.

==הגדרה: ==
נגדיר את הקומבינטור and להיות
$$and=\lambda b.\lambda c.\text{b c fls}$$
נוכח להוכיח בחלוקה למקרים:
אם $b=tru$ :
	אם $c=true$ אז מפעילים את הפונקציה $\text{tru tru fls}$ ונקבל מהגדרה $tru$.
	אם $c=false$ אז נריץ את הפונקציה $\text{tru fls fls}$ ומהגדרה יוחזר $fls$.

המקרה השני כמובן תמיד יחזיר $false$.

באופן דומה :

$$Or=\lambda b.\lambda c. b \ tru \ c$$

==הגדרה: ==
__זוגות סדורים__ 
$$\displaylines{
\text{pair = }\lambda f.\lambda s.\lambda b.\text{b f s}\\

\text{first} =\lambda p.{ p \ tru }\\
\text{snd = } \lambda p.p \ fls
}$$
![Screenshot 2024-02-13 at 11.51.44.png](/img/user/Assets/Screenshot%202024-02-13%20at%2011.51.44.png)

pair זאת פונקציה שמקבל שני ארגומנטים ומחזירה פונקציה בוליאנית. אם הקלט אליה הוא tru אז היא תחזיר את f , אחרת היא תחזיר את s. הפונקציות האחרות הן דרך לשלוף את האיבר הראשון/ השני בהתאמה מהזוג הסודר. למשל כדי להוציא את האיבר הראשון נריץ $first \ pair$ .

==הגדרה: ==
__מספרים טבעיים__ 
הקומבינטורים $c_{0},c_{1},\dots$ מוגדרים כך 

$$\displaylines{
c_{0}=\lambda s.\lambda z.z \\
c_{1}= \lambda s.\lambda z.sz\\
c_{2}= \lambda s.\lambda z . s(sz)\\
c_{3}= \lambda s.\lambda z .s(s(sz))\\ \vdots
}$$

בעצם s היא פונקציית successor ו z זאת פונקציית האפס ועבור $c_{n}$ מפעילים את פונקציית הsuc $n$ פעמים.

>[!info] הבחנה
>הייצוג של $0$ הוא בידיוק כמו הייצוג של $fls$ ולכן יש שפות תכנות שבהן $0$ מוגדר כ $False$

נגדיר את פונקציית הsucc : $succ=\lambda n.\lambda s.\lambda z.s(n \ s \ z)$ 
בעצם היא מפעילה את $s$ על הפלט מהפעלת $s$, $n$ פעמים על $z$. 

==אריתמטיקה: ==
$$plus=\lambda m.\lambda n.\lambda s.\lambda z. \text{ m s(n s z)}$$

כאשר $m,n$ אמורים להיות בפועל הקומבינטורים $c_{i},c_{j}$ כלשהם.

$$times = \lambda m.\lambda n.m(plus \ n)c_{0}$$

מה זה $plus \ n$ ? זאת פונקציה שמקבלת מספר כלשהו ומוסיפה לו את $n$.

את הפונקציה הזאת מפעילים $m$ פעמים עם הקלט $c_{0}$ וסך הכל מקבלים $m\cdot n$ .

נשתמש בכלים שהגדרנו כדי לכתוב קומבינטור שמקבל מספר ומחזיר tru אם הוא 0 ו fls אחרת:

$$iszero=\lambda m.m(\lambda x.false)tru$$
![Pasted image 20240213121445.png](/img/user/Assets/Pasted%20image%2020240213121445.png)

אם $m=c_{0}$ אז הפונקציה תקבל $c_{0}$ תקבל שני ארגומנטים ותחזיר את השני ולכן במקרה הזה מתקבל $tru$. כל מקרה אחר יריץ את פונקצית ה succ במקרה הזה $\lambda x.false$ שאפשר לראות שלכל $n$ היא מחזירה $fls$ בסוף.


__פתרון לבעיית פיבונצ׳י בתחשיב למדא__
==הגדרה: ==
$$\displaylines{
zz= pair\ c_{0}\ c_{0}\\
ss = \lambda p.pair(snd\ p)(plus \ c_{1}(snd\ p))\\
prd = \lambda m.fst(m \ ss \ zz)
}$$

$zz$ מגדיר את הזוג הסדור $c_{0},c_{0}$ ו ss מקבלת זוג סדור $p$ ומחזירה זוג סדור כך ש האיבר הראשון הוא האיבר השני ב$p$ והאיבר השני הוא האיבר השני ב$p$ פלוס $1$.
כעת הפונקציה $prd$ עושה את החישוב המלא כאשר היא מחזירה את האיבר הראשון מזוג סדור המתקבל מהרצת $ss$ m פעמים עם הקלט ההתחלתי $zz$.

כעת נוכל להגדיר קומבינטורים אריתמטיים נוספים 
$$sub=\lambda m.\lambda n.n\ prd \ m$$

כמו כן נוכל להגדיר שיוויון על ידי 

$$equal = \lambda m.\lambda n.  and(iszero(sub \ m \ n)(iszero(sub \ m \ m)))$$
הסיבה שלעשות רק $iszero(sub\ m\ n)$ לא יעבור היא שהמספרים השליליים לא מוגדרים עבור $sub$ ולכן זה פשוט יצא עבור מספרים שליליים.

## לולאה אינסופית 
האתגר כאן הוא קריאה של פונקציה לעצמה שכן לפונקציות אין שם בתחשיב למדה. 

 לפני שנגדיר נשים לב שעבור הקומבינטור

$$\Omega = (\lambda x.x \ x)(\lambda x.x \ x)$$

נקבל שלפי כלל $\beta$ זה יוצא שהפלט של הפונקציה הוא הפונקציה עצמה כלומר מדובר כאן בלולאה אינסופית.
### בעיית העצירה
נזכיר ש [[Computer Science/Computational Models/Undecidable Theory#בעיית העצירה\|בעיית העצירה]] היא בעיה [[Computer Science/Computation and Complexity/NP-completeness\|NPH]] שמתארת פונקציה וארגומנט ובודקת אם היא עוצרת (מחזירה $tru$ אם עוצרת ו $fls$ אם נתקעת): 

$$Halt = \lambda f.\lambda x. \text{/*if f Halt on x /* True False}$$

נניח שזאת פונקצייה אפשרית אזי נגדיר פונקציה חדשה $IsNotHalting$ שמקבלת פונקציה ובודקת האם היא לא עוצרת כאשר היא מקבלת את עצמה כארגומנט. 

$$isNotHalting := \lambda f. Halt(f,f) \ (\Omega) \  True$$

נשים לב שאם f עוצרת על עצמה אז נכנסים ללולאה אינסופית , אם היא לא עוצרת אז הפונקציה מחזירה tru.

כעת נשאל, מה הערך שיוחזר עבור $Halt(IsNotHalting \ \   isNotHalting)$ ?

נניח שצריך לחזור אמת כלומר Halt הכריעה שהפונקציה עוצרת על עצמה __אבל__ :

![Pasted image 20240213144107.png](/img/user/Assets/Pasted%20image%2020240213144107.png)
בסתירה לכך שחזר true 

נניח שזה מחזיר false :
![Screenshot 2024-02-13 at 14.46.21.png](/img/user/Assets/Screenshot%202024-02-13%20at%2014.46.21.png)
בסתירה לכך ש Halt החזירה false

==המסקנה היא שלא קיימת פונקציה Halt.==

## רקרוסיה
כעת נגדיר את הקומבינטור Y 

$$rec = Y=\lambda f.(\lambda x .f(x\ x))(\lambda x .f(x \ x))$$

למה זה בעצם מהווה ריקורסיה? 
![Screenshot 2024-02-13 at 15.58.30.png](/img/user/Assets/Screenshot%202024-02-13%20at%2015.58.30.png)
בעצם Y מאפשר לנו להעביר כקלט פונקציה אחרת ולהפעיל אותה בצורה אינסופית. על הפונקציה שמעבירים לקבוע מה יהיה התנאי העצירה של הרקורסיה.

למשל נרצה לחשב את פונקציית העצרת: בצורה שהיא לא תחשיבית 
למדא טהורה זה היה נראה מהצורה $fact = \lambda f.\lambda n.\text{ if n =1 then 1 else n * f n-1}$ .

בצורה שמבוססת רק על תחשיב למדא זה היה נראה כך :
$$\lambda f.\lambda n.\text{ test (realeq n c1)c1(times n f pred n)}$$
![Screenshot 2024-02-13 at 16.13.27.png](/img/user/Assets/Screenshot%202024-02-13%20at%2016.13.27.png)
## Substitution
יהי $t$ ביטוי. קבוצת המשתנים החופשיים של $t$ מסומנת ב $Fv(t)$ ומוגדרת כך

$$\displaylines{
Fv(x)=\{x\} \\
Fv(\lambda x.t)=Fv(x)-\{x\}\\
Fv(t_{1},t_{2})= Fv(t_{1})\cup Fv(t_{2})

}$$

משתנה שמופיע ב $t$ נקרא חופשי ב$t$ אם הוא שייך ל $Fv(t)$ וקשור אחרת.

כעת נוכל להגדיר את כללי ה substitution $t[x\mapsto s]$ :

$$\displaylines{
x[x\mapsto s]=s \\
y[x\mapsto s]=y \\
(\lambda y.t_{1})[x\mapsto s]=\lambda y.(t_{1}[x\mapsto s]) \\
(t_{1} \ t_{2})[x\mapsto s]= (t_{1}[x\mapsto s])(t_{2}[x\mapsto s])
}$$

את $(\lambda y.t_{1})[x\mapsto s]=\lambda y.(t_{1}[x\mapsto s])$ מותר לי לעשות רק אם $y$ משתנה שונה מ $x$ ו $y\notin  Fv(s)$
נשים לב שבלי הדרישה הראשונה נקבל 

$$(\lambda x.x)[x\mapsto y]= \lambda x.y$$
הפכנו קומבינטור לביטוי שאינו קומבינטור.

בלי הדרישה השנייה נקבל 

$$(\lambda y.x)[x\mapsto y]=\lambda y.y$$

כאן הפכנו ביטוי שאינו קומבינטור לקומבינטור.

## סמנטיקה לא דטרמינסטית
הסמנטיקה של רדוקציית בטא היא לא דטרמינסטית למשל :

![Pasted image 20240213161745.png](/img/user/Assets/Pasted%20image%2020240213161745.png)

![Pasted image 20240213161843.png](/img/user/Assets/Pasted%20image%2020240213161843.png)

כדי להבין מהן השיטות לגשת לבעיות מסוג זה נגדיר קודם כל את המונח רדקס.

__הגדרה:__ ביטוי מהצורה $(\lambda \ x.t_{1})t_{2}$ נקרא רדקס. לעומת זאת, לביטוי מהצורה $\lambda x.t$  קוראים אבסטרקציה. 

$$\overbrace{\underbrace{(\lambda \ x.t)}_{abstract} \ s}^{redex}$$


כמו כן כללי הרדוקציה הקיימים בצורה פורמלית הם
![Pasted image 20240213162521.png](/img/user/Assets/Pasted%20image%2020240213162521.png)
__הראשון__ אומר ש אם ניתן לבצע רדוקציית בטא מ $t_{1}$ ל $t_{1}'$ אז הרדוקציית בטא קודם כל תהיה $t_{1}t_{2}\to t_{1}'t_{2}$ כלומר לבצע קודם כל על $t_{1}$ אם ניתן.

__השני__ אומר שאם לא ניתן לבצע על $t_{1}$ את כלל בטא אז צריך לבדוק אם אפשר לבצע על $t_{2}$.

__השלישי__ אומר שאם מדובר ב״רדקס״ אז מחזירים את $t_{1}$ עם evaluation של $x\mapsto v_{2}$ .
### evaluation strategies
כעת ננסה להבין כיצד לקרוא ביטוי מהצורה $(x \ y)(z \ w)$: מספר אסטרטגיות אפשריות:
	א) רדוקציה מלאה - אין מגבלות.
	ב) סדר נורמלי - מתחילים תמיד עם הרדקס השמאלי ביותר (החיצוני ביותר).
	![Pasted image 20240211222227.png](/img/user/Assets/Pasted%20image%2020240211222227.png)
	ג) call by name - כמו סדר נורמלי אבל לא עושים רדוקצית בטא בתוך אבסטרקציות. כלומר קודם מבצעים השמה ורק אם צריך מחשבים את הביטוי (קדימות ל E-AppAbs)
	![Pasted image 20240211222239.png](/img/user/Assets/Pasted%20image%2020240211222239.png)
	ד) call by value - מותר לבצע רדוקציית בטא על רדקס רק אם צד ימין של הרדקס הוא אבסטרקציה או משתנה. אסור לבצע רדוקציות בתוך אבסטרקציות. כלומר מבצעים השמה רק עבור משתנים ולא ביטויים. (קדימות ל E-App)
	![Pasted image 20240211222259.png](/img/user/Assets/Pasted%20image%2020240211222259.png)

![Pasted image 20240227135047.png](/img/user/Assets/Pasted%20image%2020240227135047.png)
ניתן לראות כיצד ב call by value קודם חישבו את ההפעלה ״הפנימית״ ואז החליפו בהפעלה ״החיצונית״ בעוד ש ב call by name קודם ביצעו השמה באבסטרקצייה החיצונית ואז חישבו את ההפעלה הפנימית.
# תחשיב למדא עם טיפוסים
בכל השפות תכנות יש תמיכה בטיפוסים. למשל ב[[Computer Science/Programming Concepts/Programming Languages Principles/OCaml\|OCaml]] על משנה `let x = 5` לא נוכל להתייחס כפונקציה. ויש מקרים מורכבים יותר שהקומפילר מצליח לזהות למשל קלט לא תקין לפונקציה. 

הקומפילר למעשה לא מריץ התוכנית כדי לגלות את השגיאות הללו. אלא הוא מייצר [[Computer Science/Programming Concepts/Programming Languages Principles/Semantics#AST\|Abstract Syntax Tree]] בשלב הראשון ולאחר מכן מבצע Type Checking ו (ישנן שפות כמו אוקמל שעושות גם [[Computer Science/Programming Concepts/Programming Languages Principles/Type Inference\|Type Inference]]).

נרצה להבין כיצד קומפיילרים מבצעים את הבדיקת טיפוסים הזאת 
_נשים לב ש type inference זה פיצ׳ר יותר מתקדם מ type checking ולא נתעסק בו כאן_.  

==הגדרה: ==
קבוצת הטיפוסים מוגדרת כך:
_א._ Bool 
_ב._ אם $T$ ו $S$ טיפוסים אז $T\to S$ הוא גם טיפוס.

עם ההגדרות האלה ניתן להרחיב את ההגדרות שלנו לטיפוסים נוספים למשל __מספרים טבעיים__:
נגדיר $T:== Nat$ עם החוקים הבאים :
![Pasted image 20240215132636.png|300](/img/user/Assets/Pasted%20image%2020240215132636.png)
נשים לב שזה הגדרה לא מדויקת שכן $pred \ 0$ לא משאיר אותנו בטבעיים אבל זה בסדר כי אנחנו יכולים גם להגדיר ש $pred \ 0=0$ אם נרצה. כעת נוכל להשתמש בכללי גזירה בסיסיים על הטיפוסים האלה 


==הגדרה: ==
ביטויים בתחשיב $\lambda$ עם טיפוסים מוגדרים כך:
_א._ כל משתנה הוא ביטוי.
_ב._ אם $x$ משתנה , $T$ טיפוס ו $t$ ביטוי אז $\lambda x: T.t$ הוא ביטוי.
ג. אם $t_{1},t_{2}$ הם ביטויים אז גם $t_{1}t_{2}$ 
ד. true, false הם ביטויים.
ה. אם $t_{1},t_{2},t_{3}$ הם ביטויים אז גם $if \ t_{1} \ then \ t_{2} \ else \ t_{3}$ .

__דוגמה:__ נסמן $id= \lambda x:Bool.x$ ונגדיר 
$f=\lambda x:Bool\to Bool.\lambda y:Bool \ xy$ 
זאת פונקציה שמקבלת ״שני ארגומנטים״ שמפעילה אותם אחד על השני.

נשים לב שההגדרות שלנו עדיין לא מטפלות בטיפוסים למשל $f\ true \ id$ הוא ביטוי תקין לפי ההגדרות שלנו אם כי אנחנו יודעים שהקלט הראשון ל $f$ אמור להיות פונקציה.

==הגדרה: ==
evaluation מוגדר להיות 
$$(\lambda x: T_{1}.t_{2})v_{2}\to t_{2}[x\mapsto v_{2}]$$
$$if \ true \ then  \ t_{1}\ else \ t_{2}\to t_{1}$$
$$if \ false \ then  \ t_{1}\ else \ t_{2}\to t_{2}$$

__דוגמה:__ 
נמשיך להסתכל על הפונקציות מהדוגמה הקודמת. 

$$\text{f id true}\to \text{true}$$
$$\displaylines{\text{f true id}\to (\lambda x:Bool\to Bool.\lambda y:Bool.x \ y)\to (\lambda y:Bool \ true \ y)id \\ \to true  \ id} $$

true הוא כעת ביטוי בסיסי בשפה ולפי חוקי ה evaluation לא ניתן לפתח את זה ונתקענו עם ביטוי ״בעייתי״ כלומר לפני שהגעתי לערך כלשהו. 

==הגדרה: ==
ביטוי ללא משתנים חופשיים נקרא ערך אם הוא $true,false,\lambda x:T.t$

## הקשרי הטפסה ועצי טיפוסים
==הגדרה: ==
הקשר הטפסה הוא קבוצה של היגדים מהצורה $x:T$ כך $x$ משתנה ו $T$ טיפוס.

נגדיר כעת את יחס ההטפסה להיות 
$$\Gamma\vdash t:T $$

המשמעות של זה באופן אינטואיטיבי היא שהטיפוס של הביטוי $t$ הוא $T$ , _תחת ההנחות של הטיפוסים האחרים שנקבעים ביחס $\Gamma$ שהוא הקשר הטפסה כלשהו_ .

הביטוי $\vdash t: T$ משמעותו שביטוי $t$ הוא מטיפוס $T$ בסביבה הריקה כלומר בלי הנחות מוקדמות.

![Pasted image 20240215152454.png](/img/user/Assets/Pasted%20image%2020240215152454.png)

$\vdash$ מוגדר לפי הכללים הבאים :
א. $T-var$ : $\dfrac{x:T\in \Gamma}{\Gamma\vdash x:T}$

ב. $T-True$ $\dfrac{}{\Gamma\vdash true:Bool}$

ג. $T-Flase$ $\dfrac{}{\Gamma\vdash false:Bool}$

ד. $T-IF$ $\dfrac{\Gamma\vdash t_{1}:Bool \ \ \Gamma\vdash t_{2}:T \ \ t_{3}:T}{\Gamma\vdash\text{if t1 then t2 else t3:T}}$ 
	
ה. $T-APP$ $\dfrac{\Gamma\vdash t_{1}:T_{11}\to T_{12} \ \Gamma\vdash t_{2}:T_{11}}{\Gamma\vdash t_{1}t_{2}:T_{12}}$

ו. $T-ABS$ $\dfrac{\Gamma,x:T_{1}\vdash t_{2}:T_{2}}{\Gamma\vdash \lambda x:T_{1}.t_{2}:T_{1}\to T_{2}}$
כאשר אין ב$\Gamma$ ביטוי מהצורה $\lambda x...$ במצב זה מפעילים כלל אלפה. הסימון $\Gamma,x:T_{1}$ שקול ל $\Gamma\cup\{x:T_{1}\}$ .


למשל דוגמה לשימוש בכללי גזירה לפי הקשר הטפסה:
![Pasted image 20240215132951.png](/img/user/Assets/Pasted%20image%2020240215132951.png)
![Pasted image 20240215153028.png](/img/user/Assets/Pasted%20image%2020240215153028.png)
![Pasted image 20240215153201.png](/img/user/Assets/Pasted%20image%2020240215153201.png)

נראה דוגמה נוספת על $id,f$ שהגדרנו למעלה.
נרצה לראות ש $\vdash f \ id \ true : Bool$  וגם שאין $T$ המקיים $\vdash f \ true \ id:T$ .

![Pasted image 20240215153556.png](/img/user/Assets/Pasted%20image%2020240215153556.png)

![Pasted image 20240215153948.png](/img/user/Assets/Pasted%20image%2020240215153948.png)
## Type Safety
==הגדרה: ==
ביטוי $t$ נקרא מטופס היטב אם $\Gamma\vdash t: T$ עבור $T,\Gamma$ כלשהם.
==הגדרה: ==
נכתוב $t\to^{*}t^{\prime}$ אם $t=t_{1}\to t_{2}\to\dots t^{\prime}$ .

==משפט: ==
אם $t$ ביטוי ללא משתנים חופשיים ומטופס היטב, ו $t\to^{*}t^{\prime}$ אז $t^{\prime}$ הוא ערך או שיש $t^{\prime\prime}$ כך ש $t^{\prime}\to^{} t^{\prime\prime}$ .

__הוכחה:__
ראשית נגדיר את:

__למת ההתקדמות:__ נניח ש $t$ ללא משתנים חופשיים ומטופס היטב אז $t$ ערך או שיש $t^{\prime}$ כך ש $t\to t^{\prime}$. 

__למת השימור:__ אם $\Gamma\vdash t:T$ ו $t\to t^{\prime}$ ו $t^{\prime}$ אינו ערך אז $\Gamma\vdash t^{\prime}: T$ 
כעת מכיוון ש $t\to^{*}t^{\prime}$ אז יש $t=t_{1}\to\dots t_{n} =t^{\prime}$ . נוכיח באינדוקציה על $n$ ש $t_{n}$ הוא ערך או שאפשר להתקדם ממנו וכן ש $t_{n}$ מטופס היטב.

_בסיס-_ $n=1$ אז $t=t^{\prime}$ ולכן מטופס היטב ולפי למת ההתקדמות או שהוא ערך או שאפשר להתקדם ממנו.

_צעד-_ $n>1$ ו $t^{\prime}=t_{n}$ . אם $t_{n}$ הוא ערך אז סיימנו כי כל הערכים מטופסים היטב. אחרת, לפי הגדרת האינדוקציה $t_{n-1}$ מטופס היטב ומלמת השימור מתקיים $t_{n}$ מטופס היטב. כמו כן מלמת ההתקדמות מתקיים שניתן להתקדם ממנו.

__הוכחת למת ההתקדמות:__
באינדוקציה על הגזירה של $\Gamma\vdash t:T$ (קיימים כאלה כי $t$ מטופס היטב).

בסיס: אם הכלל הוא $T-True$ או $T-False$ אז $t$ הוא ערך.
לא יתכן שהכלל הוא $T-Var$ כי ב $t$ אין משתנים חופשיים.

_צעד:_ עבור $T-ABS$ אז $t$ הוא אבסטרקציה ולכן ערך.
אם $T-APP$ אז $t=t_{1}t_{2}$ עבור $t_{1},t_{2}$ כלשהם. לפי הכלל מתקיים ששניהם מטופסים היטב ולפי הנחת האינדוקציה או שהם ערכים או שניתן להתקדם מהם לפי המקרים הבאים
	א. $t_{1}$ ניתן להתקדם ל $t_{1}^{*}$ ובמקרה כזה $t_{1}t_{2}\to t_{1}^{*}t_{2}$ 
	ב. אם ניתן להתקדם מ $t_{2}$ זה כמו סעיף א.
	ג. אם שניהם ערכים אז $\Gamma\vdash T_{11}\to T_{12}$ לפי הכלל. לכן 
	$$t_{1}=\lambda x: T_{11}.t_{12}$$
עבור $x,t_{12}$ כלשהם. 

כלומר $t_{1}t_{2}=(\lambda x.T_{11}:t_{12})t_{2}\to t_{12}[x\mapsto t_{2}]$ וכך התקדמנו.

עבור $T-IF$ נקבל הוכחה דומה.

__הוכחת למת השימור__:
נוכיח באינדוקציה על הגזירה של $\Gamma\vdash t: T$ . 
_בסיס:_ 
	1) אם T-true אז t ערך
	2) כנ״ל לגבי T-false
	3) T-VAR אז t משתנה ולכן $t\not\to \ t'$ . 

_צעד:_
	1) T-ABS אז t ערך
	2) T-IF יהיה דומה ל T-APP 
	3) T-APP 

$$\dfrac{\Gamma\vdash t_{1}: T_{11}\to T_{12} \ \  \ \Gamma\vdash t_{2}: T_{11}}{\Gamma \vdash t_{1}t_{2}:T_{12}}$$
	

כך ש $t=t_{1}t_{2}$ וגם $t_{1}=\lambda x: T_{11}. t_{11}$ ולכן $t'= t_{11}[x\mapsto t_{2}]$ .

נרצה להוכיח ש $\Gamma\vdash t_{11}[x\mapsto t_{2}]: T$ כיוון שהנחת האינדוקציה שלנו היא על $t_{1}$ ולא על $t_{11}$ ולכן נתקענו כרגע. 

כדי להמשיך את ההוכחה נשתמש ב-

__למת ההחלפה__: 
אם $\Gamma, x: S\vdash t: T$ וגם $\Gamma\vdash s: S$ אז $\Gamma\vdash t[x\mapsto s]: T$ . 
במילים, זה אומר שאם נבצע החלפה בין משתנים מאותו טיפוס, הביטוי עדיין נשאר באותו טיפוס.  

נוכיח באינדוקציה על עץ הגזירה של $\Gamma,x: S\vdash t: t$ .
_בסיס:_
	1) T-TRUE אז t=true כלומר T=Bool ולכן $t[x\mapsto s]= true$ ולכן מתקבל הדרוש.
	2)  T-FALSE דומה ל1.
	3) T-VAR אז t משתנה. נחלק ל2 מקרים 
		* $t=x$ אז $S=T$ ו $t[x\mapsto s]=s$. וכבר ידוע ש $\Gamma \vdash s: S$ .
		* $t$ משתנה אחר ואז $t[x\mapsto s]=t$ ואז נפעיל את T-VAR ונקבל את הדרוש.

_צעד_:
א) T-APP. אז $\dfrac{\Gamma,x: S\to t_{1}:T_{11}\to T_{12} \ \ \Gamma .x:S\vdash t_{2}\to T_{11}}{\Gamma, x:S\vdash t_{1}t_{2}: T_{12}}$

נרצה להראות ש $\Gamma\vdash (t_{1} t_{2})[x\mapsto s]:T_{12}$ כלומר $\Gamma\vdash t_{1}[x\mapsto s]t_{2}[x\mapsto s]:T_{12}$.

לפי הנחת האינדוקציה מתקיים ש $\Gamma\vdash t_{1}[x\mapsto s]: T_{11}\to T_{12}$ וגם $\Gamma\vdash t_{2}[x\mapsto s]: T_{11}$

נפעיל שוב את T-APP ונקבל

$$\dfrac{\Gamma \vdash t_{1}[\mapsto s]: T_{11}\to T_{12} \ \ \Gamma\vdash t_{2}[x\mapsto s]: T_{11}}{\Gamma\vdash t_{1}[x\mapsto s]t_{2}[x\mapsto s]:T_{12}}$$
שזה בידיוק מה שרצינו להוכיח. 


ב) T-ABS :
$$\dfrac{\Gamma,x:S, y:T_{1}\vdash t_{2}: T_{2} }{\Gamma, x: S\vdash \lambda y:T_{1}.t_{2}: T_{1}\to T_{2} }$$

כאשר נסמן $t=\lambda y: T_{1}.t_{2}$ ו $T=T_{1}\to T_{2}$ .
לפי הנחת האינדוקציה מתקיים $\Gamma,y:T_{1}\vdash t_{2}[x\mapsto s]: T_{2}$ אם נפעיל את T-ABS כעת נקבל את הדרוש.
$$\dfrac{\Gamma,y:T_{1}\vdash t_{2}[x\mapsto s]: T_{2}}{\Gamma\vdash \lambda y: T_{1} .t_{2}[x\mapsto s]: T_{1}\to T_{2}}$$

ג) T-IF דומה.


כעת נוכל לחזור להוכחה של למת השימור רצינו להראות ש: $\Gamma\vdash t_{11}[x\mapsto t_{2}]: T$ לאחר שהפעלנו T-APP: 

$$\dfrac{\Gamma\vdash t_{1}: T_{11}\to T_{12} \ \  \ \Gamma\vdash t_{2}: T_{11}}{\Gamma \vdash t_{1}t_{2}:T_{12}}$$

והסברנו ש $t=t_{1}t_{2}$ וגם $t_{1}=\lambda x: T_{11}. t_{11}$ ולכן $t'= t_{11}[x\mapsto t_{2}]$ .

מלמת ההחלפה די להראות 
	א) $\Gamma\vdash t_{2}:T_{11}$
	ב) $\Gamma,x:T_{11}\vdash t_{11}:T_{12}$


הסעיף הראשון ידוע מהנחות הכלל T-APP. 
לגבי ב׳ , ידוע ש $\Gamma \vdash t_{1}:T_{11}\to T_{12}$

ניתן לקבל זאת רק משימוש ב T-ABS 

$$\dfrac{\Gamma,x:T_{11}\vdash t_{11}:T_{12}}{\Gamma \vdash\lambda x:T_{11}.t_{11}:T_{11}\to T_{12}}$$

שזה בידיוק מה שרצינו להוכיח.
## נורמליזציה
נגדיר ביטוי t כמנתנרמל אם יש ערך $t'$ כך ז $t\to^{*}t'$ .
כעת, משפט הנורמליזציה אומר ש- 
אם ב t אין משתנים חופשיים ו $\vdash t:T$ אז $t$ מתנרמל.

__הוכחה:__ 
כדי להוכיח את המשפט נניח שהאסטרטגה היא CBV. כעת, נגדיר עבור טיפוס T את הקבוצה $R_{T}$ באופן הבא:
	* $R_{Bool}$ היא קבוצת כל הביטויים מטיפוס Bool שמתנרמלים
	* $R_{T_{1}\to T_{2}}$ היא קבוצת כל הביטויים t מטיפוס $T_{1}\to T_{2}$ שמתנרמלים ובנוסף לכל ביטוי $s\in R_{T_{1}}$ מתקיים ש $ts\in R_{T_{2}}$ .

_דוגמה:_ 
$(\lambda x:Bool .x)true:R_{Bool}$ 

__למה:__ אם $\Gamma t: T$ ו $t\to t'$ אז  $t'\in R_{T}\leftrightarrow t\in R_{T}$ 
נוכיח באינדוקציה על T.
_בסיס:_
	T=Bool :
		 $\leftarrow$ נניח $t\in R_{Bool}$ . מלמת השימור $\vdash t':Bool$ . מכיוון שאנו בCBV ו t מתנרמל, גם $t'$ מתנרמל
		 $\rightarrow$ דומה (פשוט יותר)

_צעד:_
	$T=T_{1}\to T_{2}$
		$\leftarrow$ נניח ש $t\in R_{T}$ כמו קודם, ברור ש $t'$ מתנרמל ומטיפוס T. 
		יהי $s\in R_{T_{2}}$. נרצה להוכיח ש $t's\in R_{T_{2}}$ .
		$t\in R_{T}$ ולכן $ts\in R_{T_{2}}$. מכיוון ש $t\to t'$ אז גם $ts\to t's$ הטיפוס של שניהם הוא $T_{2}$ ולפי הנחת האינדוקציה כיוון ש $ts\in R_{T}$ נקבל שכך גם $t's$ 
		$\rightarrow$ דומה.

כעת כדי להוכיח את הטענה הקודמת, נכליל את הטענה ונניח כי 
$$x_{1}:T_{1}, \dots , x_{n}:T_{n}\vdash t:T$$

ו $v_{1}\dots v_{n}$ ערכים מטיפוסים $T_{i}$ בהתאמה כך שלכל i מתקיים $v_{i}\in R_{T_{i}}$ אז 

$$t':=t[x_{1}\mapsto v_{1}][x_{2}\mapsto v_{2}]\dots[x_{n}\mapsto v_{n}]\in R_{T}$$

__הוכחה:__
באינדוקציה על עץ הגזירה. המקרה המעניין היחיד הוא T-ABS כאשר $t=\lambda x:S_{1}.t_{2}$. 

ברור ש $t'$ ערך ולכן מתנרמל. יהי $s\in R_{S_{1}}$. נוכיח ש $t's\in R_{S_{2}}$. מהגדרת $R_{S_{1}}$ $s\to^{*}v$ עבור v ערך כלשהו. מהלמה הקודמת $v\in R_{S_{1}}$ ולפי האנחת האינדוקציה $t_{2}[\dots]\dots [\dots]\in R_{S_{2}}$ אבל זה בידיוק מה שנקבל מ ts. 

נשים לב: עבור n=0 קיבלנו מיד את משפט הנורמליזציה לפי הגדרת $R_{T}$


>[!info] הבחנה
> המשמעות של משפט זה היא שתחשיב $\lambda$ עם טיפוסים זה מודל מאוד חלש שכן ברוב שפות התכנות הקיימות התכונה הזאת לא מתקיימת (התכונה במובנים תכנותיים היא שהקומפיילר ידע לזהות טיפוסים כך שלא נתקע או נכנס ללולאה אינסופית בזמן קומפילציה) 

## Curry Howard Isomorphism
שימוש חשוב ל typed lambda expression הוא CHI. הרעיון הוא שניתן להוכיח פסוקיות לוגיות בעזרת חישוב בתחשיב למדא עם טיפוסים:
	א) ניתן לייצר משתנים בלוגיקה פסוקית כטיפוסים.
	ב) הוכחה היא פונקציה.
	ג) נייצג אופרטורים לוגיים בעזרת תחשיב למדא על טיפוסים.

ניתן להשתמש בתחשיב למדא כמערכת הוכחה ללוגיקה פסוקית כאשר כל פרדיקט מהווה איזשהו טיפוס.

![Screenshot 2024-02-15 at 15.57.26.png|300](/img/user/Assets/Screenshot%202024-02-15%20at%2015.57.26.png)

נסתכל על הביטוי הבא 
$$P\wedge (Q\vee R)\to (P\wedge Q)\vee (P\wedge R)$$

משפט זה הוא תיאותולוגיה (פסוק שהוא תמיד אמת). ניתן להוכיח שהוא תיאותולוגיה בעזרת בניית פונקציה $f$ כך ש 

$$f:P+(Q\times R)\to (P+Q)\times (P+R)$$

כעת נוכל להראות שזה תיאותולוגיה אם נראה עת גזירה שמראה שהטיפוס של $f$ הוא אמת.



