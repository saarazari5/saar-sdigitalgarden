---
{"dateCreated":"2024-01-11 23:08","tags":["programming_language"],"pageDirection":"rtl","dg-publish":true,"permalink":"/computer-science/programming-concepts/programming-languages-principles/structural-induction/","dgPassFrontmatter":true}
---

# Structural induction 

[אינדוקציה](https://he.wikipedia.org/wiki/%D7%90%D7%99%D7%A0%D7%93%D7%95%D7%A7%D7%A6%D7%99%D7%94) היא כלי חזק להוכחה של טענות ובפרט של תכונות של תוכניות ושפות.
ההוכחה באינדוקציה מחולקת לשלושה חלקים:

א) _בסיס האינדוקציה_- המקרה הכי בסיסי ופשוט שבו קל להראות שהטענה נכונה.
ב) _הנחת האינדוקציה_- הנחה כללית שהטענה נכונה עבור מקרה כלשהו.
ג) _צעד האינדוקציה_- צ״ל שאם נוסיף צעד לאיבר שידוע שעליו הטענה מתקיימת אז גם האיבר החדש מקיים את הטענה.

>[!info] הגדרה רקורסיבית של קבוצות
>בדומה להגדרה רקורסיבית של פונקציות נוכל להגדיר הגדרות רקורסיביות על קבוצות באמצעות כללי נסיגה או כללים רקורסיביים אחרים שקובעים אילו איברים שייכים לקבוצה כתלות באיברים אחרים. הגדרות רקורסיביות הן כלי חשוב להוכחה באינדוקציה כפי שאפשר לראות על [[Computer Science/Data Structures/Binary-trees#הוכחות בעצים\|הוכחות בעצים]] 

## אינדוקציה מתמטית 
אינדוקציה מתמטית היא אינדוקציה שבבסיסה היא עוסקת במספרים טבעיים וכללים על מספרים טבעיים. 

לדוגמה נגדיר את הקבוצה הבאה 

$$\displaylines{
3\in A\\ \forall_{a\in A}: a+3\in A
}$$

בעצם $A=\{3n \ | \ n\in\mathbb{N}\}$ . 

נרצה להוכיח ש $\forall_{3n\in A} : 3|a$ .  קל להוכיח זאת באינדוקציה מתמטית. הבסיס יהיה $a=3$ וההנחה תהיה שמתקיים עבור $a\in A$ כלשהו וקל להסביר למה עבור $a+3$ הטענה גם מתקיימת. 

__הגדרה__: $P(a)$ מוגדר להיות פרדיקט (טענה שמחזירה true או false ) כלשהו על $a$ במקרה הזה $3|a$ . 

__נשים לב:__ היינו יכולים להגדיר את $a$ כאיבר מהצורה $3n$ ולהוכיח באינדוקציה מתמטית עם הבסיס $n=1$
## אינדוקציה מבנית
באינדוקציה מתמטית הוכחנו את הטענה עבור מספר טבעי $n$ , באינדוקציה מבנית אנחנו מוכיחים שהטענה נכונה עבור כל איבר במבנה.

נניח שיש לנו $A$ קבוצה של איברים שנוצרה מהגדרה רקורסיבית, נרצה להוכיח שמתקיים פרדיקט $P$ לכל איבר בקבוצה. כלומר : $\forall_{a\in A}: P(A)=\text{ true }$ .

__בסיס האינדוקציה:__ נראה ש $P$ מתקיים עבור איבר הבסיס.
__הנחת האינדוקציה:__  נניח $P(a)$ עבור $a\in A$ כללי.
__צעד האינדוקציה:__ אם הטענה נכונה לאיבר $a\in A$ אז הטענה נכונה לאיברים ש״נובעים״ ממנו לפי כללי הרקורסיה.

לדוגמה - עבור הדוגמה של אינדוקציה מתמטית ממקודם הבסיס יהיה האיבר $3$ וכמובן שמתקיים $3|3$ .
ההנחה תהיה $P(a)$ עבור $a$ כלשהו כלומר $3|a$ . האיבר הבא הוא $a+3$ ולכן טריוויאלי שהוא מקיים $3|a+3$ . 

__דוגמה 2:__ 
נגדיר קבוצה $A$ כ 

$$\displaylines{
(4,5),(5,4)\in A \\ \forall_{(a,b)\in A}\to (a+5,b+4),(a,b+9)\in A
}$$

נרצה להוכיח את הטענה ש $\forall_{(a,b)\in A}: 9|(a+b)$ כלומר $P(a,b): 9|(a,b)$ .

__בסיס האינדוקציה:__ איברי הבסיס הנ״ל מקיימים את הדרוש שכן סכומם הוא $9$. 
__הנחת האינדוקציה:__ נניח $P(a,b)$ עבור $(a,b)\in A$ 
__צעד האינדוקציה:__ מההנחה מתקיים $9|a+b$ נתבונן באיברים הבאים בתור: $(a+5,b+4),(a,b+9)$
נסמן $a+b= 9k$ שכן הסכום מתחלק ב$9$ . מתקיים ש $a+5+b+4=9k+9=9(k+1)$ שכמובן מתחלק ב$9$. ועבור האיבר השני $a+b+9=9k+9=9(k+1)$ שבאותו אופן מתחלק ב$9$

### אינדוקציה מבנית על עצים בינאריים
נוכיח טענה באמצעות אינדוקציה מבנית על [[Computer Science/Data Structures/Binary-trees#עץ בינארי מלא full binary tree\|עץ בינארי מלא]]. נרצה להוכיח את הטענה שכמות העלים שווה לכמות הקודקודים הפנימיים בעץ ועוד אחד. 

לשם נוחות נסמן: $e(t)$ - פונקציה המחזירה את כמות העלים בעץ , $b(t)$ - פונקציה המחזירה את כמות הקודקודים הפנימיים בעץ. צ״ל ש $e(t) = b(t)+1$

__בסיס:__ עבור עץ $T$ עם קודקוד בודד מתקיים $e(T)=1$ ו $b(T)=0$ ולכן מתקיים הדרוש.
__הנחה:__ עבור עץ $T_{1}$ מתקיים $e(T_{1})=b(T_{1})+1$ וכנ״ל עבור עץ $T_{2}$.

__צעד:__ נגדיר $T$ שהוא עץ עם קודקוד שורש ותת עץ ימני שהוא $T_{2}$ ותת עץ שמאלי שהוא $T_{1}$. מתקיים :

$$e(T)=e(T_{1})+e(T_{2})= b(T_{1})+b(T_{2})+2$$
מתקיים גם ש 

$$b(T)=b(T_{1})+b(T_{2})+1 $$ 
כאשר התוספת $1$ היא בגלל קודקוד השורש. אם נציב במשוואה למעלה נקבל $e(T)=b(T)+1$  __כדרוש__ .


### אינדוקציה מבנית על דקדוק חסר הקשר
נראה כעת כיצד להוכיח טענות על [[Computer Science/Computational Models/Context-free language\|דקדוק חסר הקשר]] באמצעות אינדוקציה מבנית.
נייצג את המספרים הטבעיים $N$ בעזרת דקדוק חסר הקשר, ישנם 3 דרכים לייצוג: 

__Production Rules:__

$$\displaylines{
\mathbb{N}\to 0 \\ \mathbb{N}\to S(\mathbb{N})
}$$

__Backus-Naur Form (BNF):__

$$\displaylines{\mathbb{N}::=0|S(N)}$$

__Derivation Rules:__

$$\displaylines{
\text{zero } \ \  \frac{} {0\in \mathbb{N}} \\\\ \text{succ} \ \ \frac{x\in \mathbb{N}}{S(x)\in \mathbb{N}}
}$$

כאשר הסימון של כללי גזירה הוא ״מלמעלה אפשר לגזור את מה שכתוב למטה״. 

כעת נייצג את הקבוצה $M$ באופן הבא: 

$$\displaylines{ M::= 0|S(0)|S(S(M))}$$

ובאמצעות כללי גזירה :

$$\displaylines{
\text{zero } \ \  \frac{} {0\in M} \\\\ \text{one }\ \ \frac{}{S(0)\in M} \\\\  \text{succ} \ \ \frac{x\in M}{S(S(x))\in M}
}$$

נרצה להוכיח ש $\mathbb{N}= M$ על ידי הכלה דו כיוונית באמצעות אינדוקציה מבנית.

$\leftarrow$ : $M\subseteq N$ - 
_בסיס_ - עבור איברי הבסיס של $M$ שהם $(0,S(0))$ נקבל ש $0\in N$ מהגדרה וגם מכלל הגזרה השני של המספרים הטבעיים $\frac{}{\frac{0\in N}{S(0)\in N}}$ . 

_הנחת האינדוקציה-_ יהי $x\in M\cap N$ .

_צעד_- אם $x\in M$ אזי $S(S(x))\in M$ ונרצה להראות שזה שייך גם ל $N$ . קל להראות זאת באמצעות אותם כללי גזירה $x\in N \bigg{|} S(x)\in N \bigg{|} S(S(x))\in N$  כלומר הפעלת כלל הגזירה $succ$ פעמיים. 

$\rightarrow$ $M\supseteq N$ -
_בסיס_ - איבר הבסיס של $N$ הוא $0$ ומכלל הגזירה מתקיים שהוא אכן ב $M$ 

_הנחה -_  יהי $x\in M\cap N$ .

_צעד-_ עבור $x\in N$ מתקיים ש $S(x)\in N$ ונרצה להוכיח שגם הוא שייך ל $M$. כיוון ש $x\in M$ מתקיים ש $S(S(x))\in M$. 

נשים לב שנתקלנו במבוי סתום, שכן לא ניתן לגזור מתוך החוקים של $M$ את $S(x)$ .

==מה עושים?== הפתרון הוא להוכיח טענה חזקה יותר באמצעות אינדוקציה מבנית, במקרה הזה הפתרון הוא להוכיח ש $\forall_{x\in N}: x\in M\wedge S(x)\in M$ . הסיבה שזה עובד היא בגלל כלל גזירה של $M$ שלא ניצלנו אותו שהוא הכלל $one$ .

אם נרצה להוכיח את הנ״ל נוכל להראות ש $S(0)\in M$ בקלות כי $0\in M$ . 
הכוח פה כעת הוא בהנחת האינדוקציה שכן נקבל $x\in N\cap M \wedge S(x)\in M$ וכעת בצעד יותר קל לנו להוכיח את הדרוש.

#### ביטויים אריתמטיים
נגדיר דקדוק חסר הקשר שיוצר ביטויים מתמטיים עם מספרים טבעיים והאופרטורים $+,*,()$ 

$$E::= n|E+E|E*E|(E)$$

או באמצעות סדרת כללי הגזירה 

$$\displaylines{
\frac{}{n\in E} \\ \\ \frac{e_{1}\in E \  \  \ \ e_{2}\in E}{e_{1}OPe_{2}} \text{ where: }OP\in\{*,+\} \\ \\ \frac{e\in E}{(e)\in E}
}$$

 נשים לב שהדקדוק הוא רב משמעי, למשל נראה ש  $(5+3)*2+5\in E$ באמצעות עץ גזירה
 
 ![Screenshot 2024-01-13 at 2.27.40.png](/img/user/Assets/Screenshot%202024-01-13%20at%202.27.40.png)

>[!info] AST
>שפה מהסוג הנ״ל אפשר לבטא באמצעות [Abstract Syntax Tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree) בעזרתו אפשר ליצור את כל המילים בשפה ונצטרך [interpeter](https://en.wikipedia.org/wiki/Interpreter_(computing)) שיסביר מהי המשמעות ([[Computer Science/Programming Concepts/Programming Languages Principles/Semantics\|סמנטיקה]]).

### אינדוקציה מבנית על פונקציות ב OCaml
נגדיר את הפונקציה הבאה ב[[Computer Science/Programming Concepts/Programming Languages Principles/OCaml\|OCaml]] 

```OCaml
let rec m = fun t -> match t with
	| Leaf(a) -> Leaf(a)
	| Node(t1,t2) -> Node(m(t2), m(t1))
```

פונקציה שעושה mirror לעץ בינארי (החלפה בין הילדים)  ונרצה להוכיח את הטענה הבאה : $\forall_{T} : m(m(T))=T$ כאשר $T$ הוא עץ בינארי.

>[!warning] הוכחה שגויה
>הוכחה שגויה תהיה להגיד שהפונקציה $m$ הופכת את העץ בקלט ולכן ברור שהיפוך של היפוך מחזיר את העץ המקורי. הבעיה עם ההוכחה הזאת היא שהנחנו שהפונקציה $m$ אכן נכונה.

נראה כעת כיצד להוכיח באמצעות אינדוקציה מבנית:
_בסיס-_ `t=Leaf(a)` עבור עלה כלשהו, לפי הגדרת $m$ נקבל ש $m(t)=t$ ולכן $m(m(t))=t$ .

_הנחה-_ יהיו $t1,t2$ מטיפוס $tree$ ונניח $m(m(t_{1}))=t_{1},m(m(t_{2}))=t_{2}$ 

_צעד-_ $t=Node(t_{1},t_{2})$ ומתקיים 

$$\displaylines{
m(m(t))=m(Node(m(t_{2}),m(t_{1})))\\= Node(m(m(t_{1}),m(m(t_{2})))) \\ = Node(t_{1},t_{2})=t} $$

__כדרוש__

