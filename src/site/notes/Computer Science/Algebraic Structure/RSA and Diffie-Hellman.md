---
{"dateCreated":"2023-02-28 10:58","tags":["abstract_algebra","computer_science"],"pageDirection":"rtl","dg-publish":true,"permalink":"/computer-science/algebraic-structure/rsa-and-diffie-hellman/","dgPassFrontmatter":true}
---

 
# RSA 
דוגמה לשימוש מעשי ב[[Computer Science/Algebraic Structure/groups\|תורת החבורות]] הוא מערכת הצפנה RSA. מערכת זו מממשת שיטה ל[הצפנה אסימטרית](https://he.wikipedia.org/wiki/%D7%9E%D7%A4%D7%AA%D7%97_%D7%A6%D7%99%D7%91%D7%95%D7%A8%D7%99) כלומר מערכת מבוססת מפתח ציבורי.

__בר רוצה לשלוח מסר $x$ לאילן.__
נתאר את התרחיש הבא-
__יצירת המפתח__:
* אילן מכין ״מנעול״ שיישלח לבר. הוא בוחר 2 ראשוניים גדולים (בקירוב של $2^{1024}$). נסמנם $p,q$ .
* אילן מחשב $n=pq$ .
* אילן מחשב בנוסף $m=\varphi(n)=(p-1)(q-1)$. 
* אילן מגריל $e$ שזר ל $m$
* אילן מחשב את $d=e^{-1}\in U_{m}$ 

__הפצת המפתח:__ 
* אילן מפרסם לבר באופן אמין אך לא בהכרח מוצפן את הזוג $(n,e)$ 
* $d$ הוא מפתח סודי והוא שומר אותו לעצמו. 

__הצפנה__:
* בר שולחת מסר $1\leq x<n$ . $x$ הוא מספר אבל הוא יכול להוות מוסכמה על מסר כלשהו $M$ זה כבר תלוי במידע שרוצים להעביר.
* בר שולחת $y=x^{e}\mod n$ לאילן.

__פענוח__:
אילן מחלץ את המספר על ידי החישוב הבא $x=y^{d}\mod n$ 

## דוגמה להצפנה
אילן מגריל את $p=61$ ו $q=53$
כעת מתקיים 

$$n=pq=3233$$

$$\varphi(n)=(p-1)(q-1)=3120$$

אילן מגריל בנוסף $e=17$ (הוא ראשוני ולכן זר לנ״ל) ויתקיים שהמפתח הסודי הוא 

$$d\equiv_{3120} e^{-1}\equiv_{3120} 2753$$

כעת אילן מפרסם את $(3233,17)$ ומחכה...
בר רוצה לשלוח את $x=65$ לאילן. היא מחשבת את ההודעה המוצפנה 

$$y=x^{17} \ mod \ \ 3233= 2790 $$

בר שולחת את $y$ לאילן... והוא מחלץ את המידע באמצעות $d$ כלומר

$$x=2790^{2753}\equiv_{3233} 65$$

>[!warning] ישנן כמה שאלות שעולות לנו
>1) איך בכלל מחשבים חזקות בצורה מהירה כדי לזרז את הליך החישוב?
>2) איך מגרילים שתי מספרים ומבטיחים שהם ראשוניים?
>3) איך מוצאים את ההופכי $d$?

## נכונות
כדי להראות נכונות נוכיח שתי טענות מרכזיות
__טענה 1__ : $\varphi(n)=m$
אנחנו יודעים שהמשמעות של [[Computer Science/Algebraic Structure/Oiler group\|פונקציית אוילר]] היא סדר של חבורה אוילר כלומר כל המספרים שזרים ל $n$ ב $Z_{n}$ . כיוון ש $n=pq$ כלומר מכפלת שתי ראשוניים שקטנים ממנו אז נצטרך להסיך מהטווח $[n]$ את כל המספרים שהם מחלקים של $n$ שזה בעצם $1,q,p,n$ . כיוון שנרצה להשאיר רק את מי שזר ל $n$ הרי שכל המספרים ש $p,q$ מחלקים נצטרך להוריד גם אותם. אלו בעצם יהיו 

$$\{iq\ \ | \  i\in[p]\} \ \ \{jp \ |\ j\in[q]\}$$
כל המספרים בטווח הזה בוודאות קטנים מ $n$ מאיך שהוא מוגדר ולכן הם נמצאים בטווח הזה. סך הכל מספר האיברים בטווח הזה יהיה

$$|[n]|-(p+q-1)= n-(p+q-1)=pq-p-q+1 =(p-1)(q-1)$$

_הורדנו $1$ בגלל שבשתי הקבוצות ספרנו את $n$ כלומר ספרנו אותו פעמיים._

__טענה 2__ : $y^{d}\equiv_{n}x$ 
מתקיים $d=e^{-1}\in U_{m}$ ולכן $de\equiv_{m}1$  כלומר $de=1+k\cdot m$. נשים לב גם ש $y^{d}=(x^{e})^{d}=x^{ed}\in Z_{n}$ כאשר פעולת החזקה היא עם מודולו $n$.  
_נחלק למקרים:_
* אם $x$ זר ל $n$ - כלומר $x\in U_{n}$ ולכן $x^{\varphi(n)}=1$ מ[[Computer Science/Algebraic Structure/Oiler group#פונקציית אוילר\|משפט אוילר]]  כלומר יתקיים סך הכל 

$$y^{d}=(x^{e})^{d}=x^{ed}=x^{1+km}=x\cdot (x^{m})^{k}=x\cdot(x^{\varphi(n)})^{k}\equiv_{n}x$$

* אם $x$ לא זר ל $n$ אז $q|x$ או $p|x$ , בלי הגבלת הכלליות נניח $x=t\cdot p$ . מההנחה הזאת אנחנו יודעים ש $(x,q)=1$ אחרת $pq|x$ כלומר $n$ מחלק של מספר קטן ממנו, מצב __לא אפשרי__ . מ[[Computer Science/Algebraic Structure/Oiler group#המשפט הקטן של פרמה\|המשפט הקטן של פרמה]] מתקיים $x^{q-1}\equiv_{q}1$ וסך הכל... 

$$x^{km}=x^{k(p-1)(q-1)}=(x^{q-1})^{k(p-1)}\equiv_{q}1$$

לכן, $x^{km}=hq+1$ ואם נציב ב $y$ נקבל

$$y^{d}=x^{1+km}=xx^{km}=x(hq+1)=x+hqx= x+hqtp=x+nhp\equiv_{n}x$$

## העלאה מהירה בחזקה
התשובה לשאלה הראשונה תמונה בשאלה די יעילה להעלות בחזקה בצורה מהירה כאשר מחפשים את התוצאה לאחר שארית. 
נרצה להעלות בחזקות ריבועיות. הכי קל יהיה להדגים:

נניח שנרצה לחשב את $x^{17}$ נשים לב שמתקיים $17=16+1$ כלומר נוכל לחשב את $x^{16}$ באופן הבא

$$x,x^{2},(x^{2})^{2},(x^{4})^{2}, (x^{8})^{2}$$

ולהכפיל את התוצאה ב $x$. ביצענו פחות פעולות ואחרי כל העלאה בריבוע נבצע mod אם צריך וככה גם נעבוד עם מספרים נמוכים יותר.


## אלגוריתם מילר רבין
נרצה למצוא מספרים ראשוניים גדולים. 

>[!note] עובדה
>כמות הראשוניים עד $n$ היא בערך $\frac{n}{\log n}$ . כלומר הסיכוי שמספר אקראי עד $n$ הוא ראשוני יהיה $\frac{1}{\log n}$.

האלגוריתם הינו [[Computer Science/Algorithms/probability algorithms basics\|אלגוריתם הסתברותי לאס וגאס]] ובבסיסו עומד [[Computer Science/Algebraic Structure/Oiler group#המשפט הקטן של פרמה\|המשפט הקטן של פרמה]] שאומר שעבור $p$ ראשוני אז $a^{p-1}\equiv_{p}1$ . הבעיה עם המשפט הזה היא שיש מספרים לא ראשוניים שמקיימים אותו לכל $a$ ולכן צריך לפתור את זה באופן הסתברותי ולצמצם את אחוז השגיאות. לפני שניגש לאלגוריתם מספר טענות חשובות

__טענה 1__ יהי $p$ ראשוני ו $x\in Z_{p}$ אזי $x^{2}=1\leftrightarrow x=\pm 1$ . כלומר $x=1\vee x=p-1$.

_הוכחה-_
בכיוון הראשון ברור שאם $x$ הוא אחד מהערכים הנ״ל אז העלאה שלו בריבוע תיתן $1$.
בכיוון השני מתקיים ש $x^{2}-1=0\to (x-1)(x+1)=0$
אמרנו כבר ש $Z_{p}$ הוא שדה ולכן אין מחלקי $0$ ולכן $x-1=0$ או $x+1=0$ .

>[!info] הבחנה חשובה
>אם $p$ ראשוני גדול מ 2 אז $2|p-1$ ולכן $p-1=2^{s}\cdot r$ מכאן כבר אנחנו יכולים להבין לאן האלגוריתם הולך... נבטא את $a^{p-1}$ כ $a^{2^{s}\cdot r}$ ונתחיל לחשב את השורשים. בהמשך נראה בידיוק איך זה יעבוד

__עד חזק לראשוניות__
יהי $n>1$ טבעי (ואי זוגי, אחרת הוא בוודאות לא ראשוני) ויהי $a\in[n]$ . נסמן $n-1=2^{s}\cdot r$ ו
$a$ ייקרא __עד חזק__ לראשוניות של $n$ אם אחד מהתנאים הבאים מתקיים 
1) $a^{r}\equiv_{n}1$
2) $a^{2^{j}r}\equiv_{n}-1$ כאשר $j\in\{0,\dots,s-1\}$ 

__כעת נשים לב שאם $p$ ראשוני מפרמה הקטן כל $a$ יהיה עד חזק. אם $p$ אינו ראשוני אז לכל היותר $\frac{1}{4}$ מבין ערכי $a$ יהיו עדים חזקים.__

כעת נבין את הרעיון לפי דוגמה $p=41$ . לפי פרמה $a^{40}\equiv_{41}1$ וכעת מתקיים $a^{20}\equiv\pm 1$ אם הוא $1$ נוכל להמשיך אחרת נעצור... ולכן זאת הסיבה שמספר $a$ יהיה עד חזק לראשוניות אם הוא יעמוד בתנאים הנ״ל. במקרה של הדוגמה הנ״ל אם נמשיך נקבל $r=5$ אם הוא היה $1$ אז סיימנו והוא עד חזק, אחרת ממשיכים לעלות בחזקת $2$ עד שמקבלים $-1$ בחזקה כלשהי או שיקרה אחד מהשניים: 
1) אם המספר שהגענו אליו שקול מודולו $n$ ל $1$ אז שום העלאה בריבוע שנעשה לא תוביל אותנו לשקילות מודולו של $-1$ ונוכל לצאת מהלולאה.
2) אם הגענו לחזקה אחת לפני $p-1$ וקיבלנו $1$ גם נוכל לצאת ולהחזיר פריק. 

__האלגוריתם__:
![Pasted image 20230228202832.png](/img/user/Assets/Pasted%20image%2020230228202832.png)

## חישוב ההופכי
חישוב ההופכי אפשר לעשות בקלות לפי [[Computer Science/Algebraic Structure/Euclid Division Algorithm\|אלגוריתם אוקלידס המורחב]] . נניח שיש לנו $x\in U_{n}$ עבורו נרצה לחשב את $x^{-1}$ [[Computer Science/Algebraic Structure/Oiler group\|בחבורת אוילר]] $U_{n}$ . אם כן אנחנו יודעים שמתקיים 

$$x\cdot x^{-1}\equiv_{n}1$$

כלומר  $n$ מחלק את הביטוי

$$\displaylines{
n|(xx^{-1}-1)
}$$

המשמעות ש $n$ מחלק את הביטוי היא שקיים $k$ כלשהו כך ש 

$$nk=xx^{-1}-1\to xx^{-1}-nk=1$$

נשים לב ש $gcd(x,n)=1$ כי $x\in U_{n}$ כלומר הוא זר ל $n$ ולכן הביטוי הנ״ל הוא צירוף ליניארי מינימלי עבור הgcd כלומר נוכל להשתמש באלגוריתם אוקלידס המורחב לחשב את $(n,k)$ ולהציב כדי להגיע למקדמים האלו. באלגוריתם שלנו מדובר ב $d$ שנמצא ב $U_{m}$ אבל הצעדים זהים.

# דיפי-הלמן
הרעיון הוא בדיקת אוטנטיות עבור הצדדים ברשת. חתימה מבטיחה את זהות הכותב ושלמות המידע כאשר נרצה לתקשר או להוריד מידע ממקום מסוים ברשת, נרצה לדעת כי המקום שממנו אנחנו מורידים באמת שייך לחברה\ לערוץ ממנו אנחנו רוצים לקבל את המידע. כאשר קונים את המחשב יש עליו מספר מפתחות צרובים שמהם אנחנו ניגשים למקומות בטוחים ומשם מקבלים חותמת של אוטנטיות עבור המקומות מהם אנחנו מקבלים מידע. מתי זה חשוב? למשל אם יש עדכון תוכנה עבור מערכת ההפעלה נרצה לוודא שאנחנו מתקינים רק דברים שבוודאות מגיעים ממיקרוסופט ולא ממקום אחר.
כדי לתאם סוד משותף שכזה נשתמש בדיפי הלמן.

א) נבחר $p$ ראשוני גדול מאוד.
ב) בוחרים $g\in U_{p}$ מפורסם.
ג) אילן בוחר $a$ בר בוחרת $b$ .
ד) אילן שולח לבר את $g^{a}\mod p$ . 
ה) בר שולחת לאילו את $g^{b}\mod p$ .
ו) כל אחד מהם מעלה בחזקת המספר שבחר והם מקבלים $g^{ab}\equiv_{p}g^{ba}$ . הסוד המשותף הוא $g^{ab}\mod p$ . 

==_הרעיון== הוא שלחלץ את $a$ או את $b$ היא בעצם קשורה לפתרון של בעיית הלוג הדיסקרטי שזאת בעייה מאוד קשה. ב RSA הקושי בפתרון הוא למעשה בעובדה ש $d$ הוא סודי והעלאה בחזקה מאוד גבוהה דיסקרטית היא גם בעיה מאוד קשה חישובית._

>[!info] הבחנה
>אלגוריתם זה הוא הבסיס ל[הצפנה סימטרית](https://he.wikipedia.org/wiki/%D7%A6%D7%95%D7%A4%D7%9F_%D7%A1%D7%99%D7%9E%D7%98%D7%A8%D7%99) 

