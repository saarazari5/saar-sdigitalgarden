---
{"dateCreated":"2023-03-16 16:39","tags":["computational_models","computer_science"],"pageDirection":"rtl","dg-publish":true,"permalink":"/computer-science/computational-models/regular-languages/","dgPassFrontmatter":true}
---



# שפות רגולריות 

ראשית נזכיר כמה תכונות הנוגעות לשפות רגולריות.
בכלל, שפה $L$ תקרא רגולרית אם קיים אוטומט סופי $A$ המקבל אותה. 
1.  הדוגמה הפשוטה ביותר לשפה רגולרית היא השפה הריקה. כיוון שכל אוטומט סופי דטרמיניסטי חסר מצבים מקבלים יתאר אותה.
2. גם השפה המכילה את המילה הריקה בלבד היא רגולרית (כמו שאמרנו מספיק אוטומט עם מצב התחלתי שהוא גם מקבל).

#### סגירויות  
השפות הרגולריות סגורות ל 
* שרשור
* חיתוך
* איחוד
* משלים
* סגור קלין
* reverse (ההוכחה פשוטה, פשוט הוכפים את כל המצבים המקבלים ההתחלתיים והמעברים)
* prefix 

__תזכורת מה זה prefix ,suffix , postfix :__

$$\displaylines{
\text{prefix(L)}=\{x\in\Sigma^{*}\ | \ \exists_{y\in\Sigma^{*}}:xy\in L\}\\
\text{suffix(L)}=\{y\in\Sigma^{*}\ | \ \exists_{x\in\Sigma^{*}}:xy\in L\} \\
\text{sub(L)}=\{y\in\Sigma^{*}\ | \ \exists_{x,z\in\Sigma^{*}}:xyz\in L\}
}$$

#### ביטוי רגולרי
דרך נוספת לתאר שפה רגולרית. מחרוזת תהיה ביטוי ריגולרי אם היא אחת מהצורות הבאות 

__בסיס האינדוקצייה__ 
* $\sigma$ אות בודדת
* $\varepsilon$ המחרוזת הריקה
* $\emptyset$ הקבוצה הריקה

__פעולות האינדוקצייה__  בהינתן $r_{1},r_{2}$ ביטויים רגולרים
* $r_{1}r_{2}$ 
* $r_{1}|r_{2}$
* $r_{1}^{*}$ 
* $(r_{1})$ 

__סדר פעולות__ :
1) סוגריים
2) כוכבית
3) שרשור
4) איחוד
5) משמאל לימין


![Pasted image 20220710120803.png](/img/user/Assets/Pasted%20image%2020220710120803.png)

__שקילות__
 $L$ רגולרית אם ורק אם ישנו ביטוי רגולרי $r$ כך ש $L=L(r)$ . 
ההוכחה של זה בכיוון הראשון (שישנו ביטוי רגולרי $r$ ...) מבוצעת באינדוקצייה על אורך הביטוי $r$ . 
ההוכחה בכיוון השני קצת יותר מורכבת : 

לשם כך צריך לבנות __אוטומט סופי מוכלל__ שזה אוטומט סופי המאפשר שהמעברים יהיו ביטויים רגולרים. (זה אפשרי באוטומט סופי לא דטרמינסטי).

הדרישות לאוטומט סופי מוכלל :
1) מצב מקבל יחיד בלי יציאות ומצב התחלתי יחיד בלי יציאות.
2) קשת בין כל שני קודקודים, כולל קשתות עצמיות, המסומנות בביטויים רגולרים. 


האלגוריתם המרה יעבוד באופן הבא 

* הוספת מצב התחלתי ומצב מקבל חדש המחובר למצבים הישנים על ידי מעברי אפסילון
* השלמת כל המעברים החסרים על ידי מעבר של $\emptyset$ (אפשר להפתר מהמעברים האלה זה רק עניין פורמלי)
* בניית מעברים ישירים בין מצבים שיש בינהם מספר מעברים, מבוססי ביטויים רגולרים. אחרי שעשינו זאת נמחק את כל מצבי הביניים 
* נמשיך כל עד למחיקת כל המצבים חוץ מהמצב ההתחלתי והמצב המקבל.


#### למת הניפוח לשפות רגולריות 
אם $L$ שפה רגולרית אז קיים קבוע $N$ כך לשכל $w\in L$ שמקיימת $\#w\geq N$ קיימת חלוקה של $w$ לתתי המילים $x,y,z\in\Sigma^{*}$ כך ש $w=xyz$ ומתקיימים התנאים: 

1) $|y|>0$
2) $|xy|\leq N$ 
3) $\forall_{i\in\mathbb{N}} :xy^{i}z\in L$ 

__נשים לב שזה לא תנאי הכרחי ומספיק__ כלומר אם שפה רגולרית היא תקיים את זה אבל יכולות להיות שפות לא רגולריות שמקיימות את זה גם כן.
לכן השימוש בלמת הניפוח יבוא לידי ביטוי בעיקר בהוכחה ששפה אינה רגולרית. 

![Pasted image 20220710164516.png](/img/user/Assets/Pasted%20image%2020220710164516.png)

__ניתן להשתמש גם בתכונות הסגירות כדי להפריך ששפה אינה רגולרית__.


