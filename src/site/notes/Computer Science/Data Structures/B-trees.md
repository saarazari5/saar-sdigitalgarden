---
{"dateCreated":"2022-11-09 20:13","tags":["data_structures","computer_science"],"pageDirection":"rtl","dg-publish":true,"permalink":"/computer-science/data-structures/b-trees/","dgPassFrontmatter":true}
---


# עצי B
## עצי חיפוש מסדר גבוה
אם נרצה, נוכל להכליל את כל המונחים שדיברנו עליהם עד עכשיו בהקשר של עצי חיפוש בינאריים, נוכל להגדיר עץ חיפוש מדרגה $m$ כאשר $m\geq 2$ אשר כל קודקוד בעץ הזה יקיים שיש לו לכל היותר $m$ ילדים ויכול להכיל לכל היותר $m-1$ מספרים בתוכו.

עצי חיפוש בינאריים הם מקרה פרטי של ההגדרה הזאת שכן $m=2$ . כלומר הם עצי חיפוש מסדר $2$ . ולכן יש להם גם רק ילד אחד בכל קודקוד.

__הגדרה__ סדר= דרגת קודקוד= מספר הבנים שיש לאותו קודקוד.

* אם דרגת הקודקוד היא $k$ אז לקודקוד יהיו $k-1$ ערכים פנימיים ו $k$ מצביעים.

הגדרת ההכנסה לעץ כזה תהיה הכללה  להכנסה לעץ בינארי :

יהי שורש $v_{x_{i}:i\in[k-1]}$  שערכיו $x_{i}:i\in[k-1]$ ו $k\leq{m}$
* תת העץ השמאלי  יכיל את הערכים שקטנים מ $x_{1}$
* תת העץ ה $i$   $2\leq{i}<k$  יכיל רק אלמנטים שגדולים מ $x_{i-1}$ 
* תת העץ הימני ביותר (ה $k$-י) יכיל רק את האיברים שגדולים מ $x_{k-1}$

למשל עץ חיפוש מסדר 4:
__שימו לב שמותר להצביע לילד שהוא null בעץ חיפוש מסדר m כללי__
![Pasted image 20220626195919.png](/img/user/Assets/Pasted%20image%2020220626195919.png)

שיטת החיפוש זהה לגמרי למה שאנחנו מכירים מהמקרה הפרטי של עץ חיפוש בינארי, עבור ערך $y$  נבדוק אם הוא שייך לסדרת המספרים בקודקוד , אם הוא לא אז בודקים באיזה טווח הוא ובהתאם לזה נכנסים לפוינטר המתאים.

__לא נתעמק ממש על הכנסה ומחיקה בעצי חיפוש מסדר גבוה כי כמו עצי חיפוש בינאריים הם חסומים ב $\Omega(n)$ .__ 
אבל!! ראינו [[Computer Science/Data Structures/AVL-trees\|עצי AVL]]  ואיך הם עוזרים לנו להקטין את החסם על הפעולות על ידי הקטנת גובה העץ. וכעת, נדבר על האלטרנטיבה לעצי חיפוש מסדר גבוה שנותנת לנו בידיוק את הכוח הזה.

## הגדרה של עצי B 
עץ $B$ הוא עץ מסדר $m$ כאשר $m>2$ המקיים את התנאים הבאים : 
* כל קודקוד חוץ מהשורש מכיל __לפחות__ $\lceil{\frac{m}{2}}\rceil-1$ ערכים . השורש מכיל לפחות ערך אחד.
* רק לקודקודים ברמה הנמוכה ביותר יכול להיות ילד ריק.

מתנאי 2 ניתן להסיר שכל העלים בעצי $B$ הם באותה הרמה. 
מהתנאי הראשון ביחד עם ההגדרה של עצי חיפוש מסדר $m$ מגביל את מספר הילדים של קודקוד פנימי (ללא השורש) בעצי $B$ להיות בין 
$$\lceil{\frac{m}{2}}\rceil...m$$ ולכל קודקוד פנימי שהוא לא שורש , כתוצאה מכך, מספר הערכים הפנימיים הוא בין 
$$\lceil{\frac{m}{2}}\rceil-1\dots m-1$$
דוגמה לעץ חיפוש מסדר $5$
![Pasted image 20220627120604.png](/img/user/Assets/Pasted%20image%2020220627120604.png)

## עומק של עץ $B$ מסדר m 
באופן כללי יתקיים עבור עץ $B$ מסדר $m$ המכיל $N$ ערכים :
$$N>2\big(\frac{m}{2}\big)^t$$
כאשר $t$ מייצג רמה מסויימת בעץ.  
מכאן אפשר להסיק ש 
$$t<\log_{m/2}\frac{N}{2}=\frac{\log_{2}N-1}{\log_{2}m -1}\in{O(\log_{m}(N))}$$
בשביל להמחיש את היעילות של זה, עבור עץ מדרגה $256$ הרמה הכי נמוכה שנגיע אליה תהיה $4$  . זאת אומרת שלמבנה שהמטרה שלו היא להכיל אובייקט בעל כמות אדירה של מידע הוא יחסית שטוח מאוד.
לפיכך, כדאי שנראה גם איך שומרים על התכונות האלה בהכנסה והוצאה .

## הכנסה 
השלב הראשון הוא חיפוש , שלב החיפוש זהה לשלב החיפוש בעץ חיפוש מסדר m רגיל.

כעת לשם ההכנסה נחלק למקרים בהינתן שנרצה להכניס את הערך $y$
* הגענו לקודקוד $v_{x_{i}:i\in[k-1]}$ המקיים $k-1<m-1$ וגם הערך $y$ יכול להכנס באינדקס $j\in[k-1]$ , במצב זה נכניס אותו פשוט לרשימה במקום המתאים . 
*  הקודקוד שאליו נרצה להכניס כבר בתפוסה מלאה, הכנסה של הערך $y$ תשבור את התנאים של עצי $B$ . (למשל הכנסת 55 לעץ למעלה).
במצב זה, נעשה מספר פעולות:
1) נכניס את הערך הרצוי ל קודקוד המתאים תוך כדי התעלמות ממצב ה $overflow$ שיצרנו.

![Pasted image 20220627124108.png](/img/user/Assets/Pasted%20image%2020220627124108.png)

2) בשלב השני נצטרך לתקן את החוסר איזון שיצרנו, (בהכרח חוסר איזון יהיה כשבקודקוד יש $m$ ערכים, לא יהיה יותר).

נסמן את האיברים בקודקוד $S=r_{i}:i\in[m]$ ונפצל אותו לתתי מערכים הבאים 
$$SL=r_{i}:i\in[\lceil{m/2}\rceil-1]$$
$$SR=r_{i}:i\in \{ \lceil{m/2}\rceil+1,\dots,m\}$$
החדים בינינו ישימו לב ש$r_{m/2}$ לא נמצא באף אחת מהקבוצות, תיכך נדבר עליו.

כעת נעשה את הדבר הפשוט הבא : נפצל את הקודקוד שהכיל את $S$ לשני קודקודים המכילים בהתאמה את הערכים שב $SL$ ו $SR$ .
שני הקודקודים החדשים יהיו ילדים ישירים של האבא  ושכנים אחד של השני(נדבר מה יכול לקרות בהמשך), כמו כן הערך שלא נכנס לרשימה ייכנס באופן ריקורסיבי לאבא שמעליו מהסיבה שכעת הוספנו עוד ילד לאבא ולכן מהגדרת העץ צריך להוסיף עוד ערך (יש הפרש של 1 בין השניים) (אם גם באבא יש $overflow$ התהליך ממשיך באופן זהה).

התוצאה על העץ הנ״ל תהיה : 
![Pasted image 20220627131447.png](/img/user/Assets/Pasted%20image%2020220627131447.png)


__בוא נראה מה קורה אם נכניס עכשיו את הערך 3 לפי השלבים הנ״ל :__ 
שלב ראשון : 
![Pasted image 20220627131552.png](/img/user/Assets/Pasted%20image%2020220627131552.png)

והשלב השני:

![Pasted image 20220627131628.png](/img/user/Assets/Pasted%20image%2020220627131628.png)

__אופס!__ קיבלנו $overflow$ גם בשורש, ובמצב זה סוף סוף העץ גדל בגובהו , בניגוד ל $AVL$ שבהכנסה ניצור עלה חדש ואז נאזן את הכל, כלומר בנייה מלמעלה למטה, כאן הבנייה היא __מלמטה למעלה__ ולכן לא צריך שום טיפול מיוחד כדי לדאוג שכל העלים יהיו באותה רמה (מדהים לא?)

מה שיקרה בדוגמה שלנו בשלב הזה היא שנמשיך כרגיל אבל הפעם בגלל שהגענו ל $overflow$ בשורש אין לנו למי לחבר את שני הקודקודים המפוצלים שיצרנו , לכן ניצור שורש חדש שערכו יהיה $r_{m/2}$ שנוצר מהפיצול.

![Pasted image 20220627132315.png](/img/user/Assets/Pasted%20image%2020220627132315.png)

__במקרה הגרוע אנחנו נבצע פיצולים כאלה כגובה העץ, המקרה הזה יהיה די נדיר ולכן המבנה הזה כל כך טוב__ .

מבחינת יעילות, כמו חיפוש הפעולה חסומה באופן הדוק בגובה העץ $\Theta(\log_m (n))$

נשים לב לנקודה נוספת, מבחינת הבנייה של המבנה  עבור $n$ ערכים. 
מפתה להגיד שפשוט מבצעים את פעולה ההכנסה $n$ פעמים ולכן זה חסום ב $O(n\log_{m}(n))$ אבל זה לא המצב, כיוון שהעץ ריק ואנחנו יודעים שבכל קודקוד פרט לשורש יכולים להיות לפחות מספר הסדר $m$ חלקי 2 ערכים פנימיים , לכן עבור $n$ ערכים יהיה לכל היותר בקירוב $2n/m$ קודקודים. שזה בעצם $O(n/m)$ פיצולים. 

## מחיקה 
כמו בעצי חיפוש בינאריים הכי קל לנו יהיה למחוק ערכים מעלים, ואם נרצה למחוק מערכים שאינם כאלה נמצא לו יורש בתוך העץ שיחליף אותו (ב $AVL$ זה יהיה עלה אחר). גם בעצי $B$ המצב יהיה דומה , אלגוריתם המחיקה ייראה כך 

ה״יורש״ להחלפה במקרה של מחיקת קודקוד שאינו עלה יימצא באופן הבא
* מציאת הקודקוד $v$ שבוא נמצא ערך המחיקה $x$ , בררגע שמצאנו יציאה מיידית לפוינטר הימני
* אם הקודקוד אינו עלה, יש לצאת מיד לפוינטר השמאלי ביותר ולהמשיך ככה עד להגעה לעלה
* הערך השמאלי ביותר בעלה שנגיע אליו הוא היורש.

(מאוד דומה למציאת הערך הבא בהדפסת inorder של עץ בינארי).

הבעיה עם מחיקה זה שיכול להיות מצב של $underflow$ , אם אין מצב כזה בקודקוד שבו רוצים למחוק את הערך , פשוט נמחק אותו. 

כעת, נניח שנרצה למחוק את הערך $60$ בעץ למעלה, הוא הערך בשורש ולכן מחיקתו תוביל לכך שאין ערכים בקודקוד, במצב זה ובמצב זה $underflow$ בקודקודים פנימיים, מיד נשלים על ידי ה״יורש״ שהגדרנו למעלה (במקרה הזה 100). 

![Pasted image 20220627145855.png](/img/user/Assets/Pasted%20image%2020220627145855.png)

על פניו נשמע מצויין , עם זאת , ניתן לראות שעלול להווצר מצב שבו בעלה יש מספר מועט מדי של ערכים, מה שלא מתאים להגדרה של עצי $B$ (במקרה שלנו יש דרישה למינימום 2 ערכים).

נשמע כאילו הפתרון יהיה למזג? כמו שעשינו פיצול בהכנסה, עם זאת זה לא המצב, כי בעוד שפיצול קודקוד זה אך ורק לפי ערכי הקודקוד , מיזוג לא בהכרח יהיה אפשרי בגלל שיש תלוי בערכי האבא. למשל אם נמזג את 110 עם הקודקוד מימינו , לא רק שנצטרך להוריד ערך אחד מהאבא אלא גם שהמצביעים לא יתאימו לערכים כלומר המצביע השמאלי לקודקוד (150,700) יכיל ערכים שקטנים וגדולים מ 150 וזה לא טוב.

בכל מקרה , נקטין את מספר הילדים ולכן קודקוד אב יצטרך להוריד ערך אחד. אבל נעשה את זה במהלך שנקרא $balancing$ 

המהלך הזה יתבצע בצורה הבאה : 
* אם השכן __המידי__ של קודקוד $v$ שהוא במצב $underflow$ מכיל מספר שיותר גבוה ממספר המינימום המותר של ערכים (כלומר שהסרת ערך אחד לא תפגע) . ניקח את הערך שהכי קרוב לקודקוד שממנו מוחקים בשכן המיידי (נסמן $x_l$) , ואת הערך שמפריד בין שני הילדים באבא נסמן $t$. נשים את $t$ בקודקוד שמצב $underflow$ במקום המתאים, ואת $x_l$ נשים במיקום של $t$ למשל עבור העץ הנ״ל ניקח את 150 , נשים אותו בקודקוד 110 מצד ימין, ואת 200 נשים במקום 150, באופן הבא :

![Pasted image 20220627151357.png](/img/user/Assets/Pasted%20image%2020220627151357.png)
__נשים לב, שכן מידי = שכן ימני אם קיים ואם לא אז שכן שמאלי__ 
* המצב השני יתרחש כאשר הורדת ערך מהשכן המידי לא מתאפשרת בגלל שגם לו יהיה $underflow$ , (למשל אם נרצה למחוק את 600) לא נוכל להשאיל את 704 . במצב זה נצטרך להשלים את הערך המתאים מהאבא ואם יש יותר מדי ילדים לאבא, יתקיים  מיזוג של הקודקוד עם שכנו הימני. בגלל המצב של underflow אנחנו יודעים שניתן לעשות מיזוג כזה אחרי שהוספנו ערך מהאבא . 
  
המיזוג ייראה כך (על מחיקת הערך 600)

![Pasted image 20220627152113.png](/img/user/Assets/Pasted%20image%2020220627152113.png)

__גם כאן יש בעיה__ מחיקת הערך 700 מהאבא יצרה $underflow$ אצלו. לכן המחיקה במצב זה המחיקה תהיה __ריקורסיבית__ כלומר שאם יש $underflow$ ,נצטרך גם פה לעשות $balancing$ . האיזון יהיה זהה למה שעשינו במחיקה מהעלה, אם אפשר להשלים מהשכן המידי , נשלים, רק שהפעם בגלל שאנחנו לא משלימים על עלה נסדר את הילדים בהתאם. למשל בדוגמה שלנו : 
![Pasted image 20220627162213.png](/img/user/Assets/Pasted%20image%2020220627162213.png)

המקרה השני , הוא מצב לא גם באבא לא ניתן לאזן מהשכן המיידי ולכן נמזג ונשלים מהאבא שמעליו (ופה נכנסת הריקורסיה המדוברת) למשל,  אם נמחק את 55 זה ייראה כך : 
![Pasted image 20220627162821.png](/img/user/Assets/Pasted%20image%2020220627162821.png)
![Pasted image 20220627162831.png](/img/user/Assets/Pasted%20image%2020220627162831.png)
וככה נמשיך באופן ריקורסיבי עד הגעה לשורש.

__גם פעולת המחיקה חסומה בגובה העץ כמו פעולה ההכנסה__. 

## וריאנטים לעצי $B$ 
ישנם וריאנטים מכל מיני סוגים שמיועדים לייעל טיפה את המימוש הנ״ל או לתאר מקרים ספציפיים למשל עצי $B+$ שמכילים בתוכם עוד כמה אפשרויות לרוטציות או עצי $B*$ שמכילים את כל המידע בילדים וכך ניתן לבצע סריקה על כל הילדים לפי הסדר. אני רוצה לפרט בקצרה על מקרה פרטי ,

### עץ 2-3
זה עץ $B$ המקיים ש $m=3$ באופן כללי כל קודקוד יכיל ערך אחד או שני ערכים , קודקוד עם ערך אחד יכיל 2 ילדים וקודקוד עם שני ערכים יכיל 3 ילדים. 

הסיבה שאני מדבר עליו היא שאני רוצה להדגים באופן ספציפי (אך ניתן לממש את זה באופן כללי) אלגוריתם בנייה של עץ כזה ממערך ממויין בזמן ליניארי. 

האלגוריתם יעבוד בצורה הבאה: 
* אם המערך מכיל 2-3 ערכים , סיימנו , נקבל שורש יחיד
* אחרת נחלק את המערך לשלישיות, כל שלישייה תהיה עלה בעץ , ואת הערך הגדול מבין השלושה נפעפע למעלה ונבנה קודקוד אבא לכולם, אם הוא מכיל 2-3 ילדים, סיימנו, אחרת נבצע את אותו התהליך ריקורסיבי על תת המערך שהוא הערכים בקודקוד האב (בעצם זה הפרס ומשול קלאסי כשתנאי העצירה הוא הסעיף הראשון של האלגוריתם). __חשוב, כשמחלקים ל3 השארית תמיד תהיה איבר אחד או שניים, עלינו לדאוג שהם תמיד יהיו האיברים האחרונים במערך בחלוקה שלנו , באופן זה הם אוטומטית יהיו העלה הכי ימני בעץ__. 

דוגמה:
![Pasted image 20220627164603.png](/img/user/Assets/Pasted%20image%2020220627164603.png)

### עצי +B
מוריד את כל ערכי העץ לילדים ומחבר מצביע בינהם וככה מקבלים את היכולת לסרוק את כל הערכים בצורה ליניארית במקום לסרוק את העץ בצורה אחרת.

![Pasted image 20230218142432.png](/img/user/Assets/Pasted%20image%2020230218142432.png)

__נשים לב שברמות מעל העלים יש עותקים של הערכים המקומיים שנועדו לאפשר חיפוש מהיר יותר__ 

__הכנסה__ -
ההבדל כעת הוא שעל מנת שלא נשבור את הסדר של העלים למטה, נעלה כל פעם עותק של המידע במצב של overflow בהכנסה ופשוט מפצלים את העלים לפי הערך שהעלנו. 

__מחיקה__-
מוצאים את הערך ברמת העלים ומוחקים אותו (בוודאות הוא נמצא כעלה). נשים לב שאין צורך למחוק את העותקים כי הם עדיין משמשים עבורו כ seperators תקינים בין העלים.

__חיפוש-__
בהתאם למה שאמרנו על מחיקה, יש צורך לחפש עד לרמת העלה על מנת למצוא את הערך. שכן יכול להיות שהשארנו את העותק כ seperator. עבור החיפוש עדיין לוגריתמי בגובה העץ.

